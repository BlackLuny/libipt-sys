/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_encoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_decoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_query_decoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_insn_decoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_block_decoder {
    _unused: [u8; 0],
}
#[doc = " The library version."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_version {
    #[doc = " Major version number."]
    pub major: u8,
    #[doc = " Minor version number."]
    pub minor: u8,
    #[doc = " Patch level."]
    pub patch: u16,
    #[doc = " Build number."]
    pub build: u32,
    #[doc = " Version extension."]
    pub ext: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_pt_version() {
    assert_eq!(
        ::std::mem::size_of::<pt_version>(),
        16usize,
        concat!("Size of: ", stringify!(pt_version))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_version>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_version))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_version>())).major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_version),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_version>())).minor as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_version),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_version>())).patch as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_version),
            "::",
            stringify!(patch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_version>())).build as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_version),
            "::",
            stringify!(build)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_version>())).ext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_version),
            "::",
            stringify!(ext)
        )
    );
}
extern "C" {
    #[doc = " Return the library version."]
    pub fn pt_library_version() -> pt_version;
}
pub const pt_error_code_pte_ok: pt_error_code = 0;
pub const pt_error_code_pte_internal: pt_error_code = 1;
pub const pt_error_code_pte_invalid: pt_error_code = 2;
pub const pt_error_code_pte_nosync: pt_error_code = 3;
pub const pt_error_code_pte_bad_opc: pt_error_code = 4;
pub const pt_error_code_pte_bad_packet: pt_error_code = 5;
pub const pt_error_code_pte_bad_context: pt_error_code = 6;
pub const pt_error_code_pte_eos: pt_error_code = 7;
pub const pt_error_code_pte_bad_query: pt_error_code = 8;
pub const pt_error_code_pte_nomem: pt_error_code = 9;
pub const pt_error_code_pte_bad_config: pt_error_code = 10;
pub const pt_error_code_pte_noip: pt_error_code = 11;
pub const pt_error_code_pte_ip_suppressed: pt_error_code = 12;
pub const pt_error_code_pte_nomap: pt_error_code = 13;
pub const pt_error_code_pte_bad_insn: pt_error_code = 14;
pub const pt_error_code_pte_no_time: pt_error_code = 15;
pub const pt_error_code_pte_no_cbr: pt_error_code = 16;
pub const pt_error_code_pte_bad_image: pt_error_code = 17;
pub const pt_error_code_pte_bad_lock: pt_error_code = 18;
pub const pt_error_code_pte_not_supported: pt_error_code = 19;
pub const pt_error_code_pte_retstack_empty: pt_error_code = 20;
pub const pt_error_code_pte_bad_retcomp: pt_error_code = 21;
pub const pt_error_code_pte_bad_status_update: pt_error_code = 22;
pub const pt_error_code_pte_no_enable: pt_error_code = 23;
pub const pt_error_code_pte_event_ignored: pt_error_code = 24;
pub const pt_error_code_pte_overflow: pt_error_code = 25;
pub const pt_error_code_pte_bad_file: pt_error_code = 26;
pub const pt_error_code_pte_bad_cpu: pt_error_code = 27;
#[doc = " Error codes."]
pub type pt_error_code = i32;
extern "C" {
    #[doc = " Return a human readable error string."]
    pub fn pt_errstr(arg1: pt_error_code) -> *const ::std::os::raw::c_char;
}
pub const pt_cpu_vendor_pcv_unknown: pt_cpu_vendor = 0;
pub const pt_cpu_vendor_pcv_intel: pt_cpu_vendor = 1;
#[doc = " A cpu vendor."]
pub type pt_cpu_vendor = i32;
#[doc = " A cpu identifier."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_cpu {
    #[doc = " The cpu vendor."]
    pub vendor: pt_cpu_vendor,
    #[doc = " The cpu family."]
    pub family: u16,
    #[doc = " The cpu model."]
    pub model: u8,
    #[doc = " The stepping."]
    pub stepping: u8,
}
#[test]
fn bindgen_test_layout_pt_cpu() {
    assert_eq!(
        ::std::mem::size_of::<pt_cpu>(),
        8usize,
        concat!("Size of: ", stringify!(pt_cpu))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_cpu>(),
        4usize,
        concat!("Alignment of ", stringify!(pt_cpu))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_cpu>())).vendor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_cpu),
            "::",
            stringify!(vendor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_cpu>())).family as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_cpu),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_cpu>())).model as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_cpu),
            "::",
            stringify!(model)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_cpu>())).stepping as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_cpu),
            "::",
            stringify!(stepping)
        )
    );
}
#[doc = " A collection of Intel PT errata."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_errata {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub reserved: [u32; 15usize],
}
#[test]
fn bindgen_test_layout_pt_errata() {
    assert_eq!(
        ::std::mem::size_of::<pt_errata>(),
        64usize,
        concat!("Size of: ", stringify!(pt_errata))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_errata>(),
        4usize,
        concat!("Alignment of ", stringify!(pt_errata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_errata>())).reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_errata),
            "::",
            stringify!(reserved)
        )
    );
}
impl pt_errata {
    #[inline]
    pub fn bdm70(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bdm70(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bdm64(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bdm64(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skd007(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skd007(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skd022(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skd022(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skd010(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skd010(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skl014(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skl014(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn apl12(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_apl12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn apl11(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_apl11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skl168(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skl168(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bdm70: u32,
        bdm64: u32,
        skd007: u32,
        skd022: u32,
        skd010: u32,
        skl014: u32,
        apl12: u32,
        apl11: u32,
        skl168: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bdm70: u32 = unsafe { ::std::mem::transmute(bdm70) };
            bdm70 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bdm64: u32 = unsafe { ::std::mem::transmute(bdm64) };
            bdm64 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let skd007: u32 = unsafe { ::std::mem::transmute(skd007) };
            skd007 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let skd022: u32 = unsafe { ::std::mem::transmute(skd022) };
            skd022 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let skd010: u32 = unsafe { ::std::mem::transmute(skd010) };
            skd010 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let skl014: u32 = unsafe { ::std::mem::transmute(skl014) };
            skl014 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let apl12: u32 = unsafe { ::std::mem::transmute(apl12) };
            apl12 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let apl11: u32 = unsafe { ::std::mem::transmute(apl11) };
            apl11 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let skl168: u32 = unsafe { ::std::mem::transmute(skl168) };
            skl168 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A collection of decoder-specific configuration flags."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pt_conf_flags {
    pub variant: pt_conf_flags__bindgen_ty_1,
}
#[doc = " The decoder variant."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union pt_conf_flags__bindgen_ty_1 {
    pub block: pt_conf_flags__bindgen_ty_1__bindgen_ty_1,
    pub insn: pt_conf_flags__bindgen_ty_1__bindgen_ty_2,
    pub query: pt_conf_flags__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[doc = " Flags for the block decoder."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pt_conf_flags__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_pt_conf_flags__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pt_conf_flags__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(pt_conf_flags__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pt_conf_flags__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(pt_conf_flags__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl pt_conf_flags__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn end_on_call(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_end_on_call(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_tick_events(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_tick_events(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn end_on_jump(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_end_on_jump(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn keep_tcal_on_ovf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_keep_tcal_on_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        end_on_call: u32,
        enable_tick_events: u32,
        end_on_jump: u32,
        keep_tcal_on_ovf: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let end_on_call: u32 = unsafe { ::std::mem::transmute(end_on_call) };
            end_on_call as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enable_tick_events: u32 = unsafe { ::std::mem::transmute(enable_tick_events) };
            enable_tick_events as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let end_on_jump: u32 = unsafe { ::std::mem::transmute(end_on_jump) };
            end_on_jump as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let keep_tcal_on_ovf: u32 = unsafe { ::std::mem::transmute(keep_tcal_on_ovf) };
            keep_tcal_on_ovf as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Flags for the instruction flow decoder."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pt_conf_flags__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_pt_conf_flags__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<pt_conf_flags__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(pt_conf_flags__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pt_conf_flags__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(pt_conf_flags__bindgen_ty_1__bindgen_ty_2)
        )
    );
}
impl pt_conf_flags__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn enable_tick_events(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_tick_events(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn keep_tcal_on_ovf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_keep_tcal_on_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enable_tick_events: u32,
        keep_tcal_on_ovf: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable_tick_events: u32 = unsafe { ::std::mem::transmute(enable_tick_events) };
            enable_tick_events as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let keep_tcal_on_ovf: u32 = unsafe { ::std::mem::transmute(keep_tcal_on_ovf) };
            keep_tcal_on_ovf as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Flags for the query decoder."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pt_conf_flags__bindgen_ty_1__bindgen_ty_3 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_pt_conf_flags__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<pt_conf_flags__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(pt_conf_flags__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pt_conf_flags__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(pt_conf_flags__bindgen_ty_1__bindgen_ty_3)
        )
    );
}
impl pt_conf_flags__bindgen_ty_1__bindgen_ty_3 {
    #[inline]
    pub fn keep_tcal_on_ovf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_keep_tcal_on_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(keep_tcal_on_ovf: u32) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let keep_tcal_on_ovf: u32 = unsafe { ::std::mem::transmute(keep_tcal_on_ovf) };
            keep_tcal_on_ovf as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_pt_conf_flags__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pt_conf_flags__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(pt_conf_flags__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_conf_flags__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(pt_conf_flags__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_conf_flags__bindgen_ty_1>())).block as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_conf_flags__bindgen_ty_1),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_conf_flags__bindgen_ty_1>())).insn as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_conf_flags__bindgen_ty_1),
            "::",
            stringify!(insn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_conf_flags__bindgen_ty_1>())).query as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_conf_flags__bindgen_ty_1),
            "::",
            stringify!(query)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_conf_flags__bindgen_ty_1>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_conf_flags__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_pt_conf_flags() {
    assert_eq!(
        ::std::mem::size_of::<pt_conf_flags>(),
        16usize,
        concat!("Size of: ", stringify!(pt_conf_flags))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_conf_flags>(),
        4usize,
        concat!("Alignment of ", stringify!(pt_conf_flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_conf_flags>())).variant as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_conf_flags),
            "::",
            stringify!(variant)
        )
    );
}
#[doc = " The address filter configuration."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pt_conf_addr_filter {
    pub config: pt_conf_addr_filter__bindgen_ty_1,
    #[doc = " The address ranges configuration."]
    #[doc = ""]
    #[doc = " This corresponds to the IA32_RTIT_ADDRn_A/B MSRs."]
    pub addr0_a: u64,
    pub addr0_b: u64,
    pub addr1_a: u64,
    pub addr1_b: u64,
    pub addr2_a: u64,
    pub addr2_b: u64,
    pub addr3_a: u64,
    pub addr3_b: u64,
    pub reserved: [u64; 8usize],
}
#[doc = " The address filter configuration."]
#[doc = ""]
#[doc = " This corresponds to the respective fields in IA32_RTIT_CTL MSR."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union pt_conf_addr_filter__bindgen_ty_1 {
    pub addr_cfg: u64,
    pub ctl: pt_conf_addr_filter__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pt_conf_addr_filter__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_padding_0: u16,
}
#[test]
fn bindgen_test_layout_pt_conf_addr_filter__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pt_conf_addr_filter__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(pt_conf_addr_filter__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pt_conf_addr_filter__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(pt_conf_addr_filter__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl pt_conf_addr_filter__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn addr0_cfg(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_addr0_cfg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn addr1_cfg(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_addr1_cfg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn addr2_cfg(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_addr2_cfg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn addr3_cfg(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_addr3_cfg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        addr0_cfg: u32,
        addr1_cfg: u32,
        addr2_cfg: u32,
        addr3_cfg: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let addr0_cfg: u32 = unsafe { ::std::mem::transmute(addr0_cfg) };
            addr0_cfg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let addr1_cfg: u32 = unsafe { ::std::mem::transmute(addr1_cfg) };
            addr1_cfg as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let addr2_cfg: u32 = unsafe { ::std::mem::transmute(addr2_cfg) };
            addr2_cfg as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let addr3_cfg: u32 = unsafe { ::std::mem::transmute(addr3_cfg) };
            addr3_cfg as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_pt_conf_addr_filter__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pt_conf_addr_filter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(pt_conf_addr_filter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_conf_addr_filter__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pt_conf_addr_filter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_conf_addr_filter__bindgen_ty_1>())).addr_cfg as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_conf_addr_filter__bindgen_ty_1),
            "::",
            stringify!(addr_cfg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_conf_addr_filter__bindgen_ty_1>())).ctl as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_conf_addr_filter__bindgen_ty_1),
            "::",
            stringify!(ctl)
        )
    );
}
#[test]
fn bindgen_test_layout_pt_conf_addr_filter() {
    assert_eq!(
        ::std::mem::size_of::<pt_conf_addr_filter>(),
        136usize,
        concat!("Size of: ", stringify!(pt_conf_addr_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_conf_addr_filter>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_conf_addr_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_conf_addr_filter>())).config as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_conf_addr_filter),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_conf_addr_filter>())).addr0_a as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_conf_addr_filter),
            "::",
            stringify!(addr0_a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_conf_addr_filter>())).addr0_b as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_conf_addr_filter),
            "::",
            stringify!(addr0_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_conf_addr_filter>())).addr1_a as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_conf_addr_filter),
            "::",
            stringify!(addr1_a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_conf_addr_filter>())).addr1_b as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_conf_addr_filter),
            "::",
            stringify!(addr1_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_conf_addr_filter>())).addr2_a as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_conf_addr_filter),
            "::",
            stringify!(addr2_a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_conf_addr_filter>())).addr2_b as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_conf_addr_filter),
            "::",
            stringify!(addr2_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_conf_addr_filter>())).addr3_a as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_conf_addr_filter),
            "::",
            stringify!(addr3_a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_conf_addr_filter>())).addr3_b as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_conf_addr_filter),
            "::",
            stringify!(addr3_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_conf_addr_filter>())).reserved as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_conf_addr_filter),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " An Intel PT decoder configuration."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pt_config {
    #[doc = " The size of the config structure in bytes."]
    pub size: usize,
    #[doc = " The trace buffer begin address."]
    pub begin: *mut u8,
    #[doc = " The trace buffer end address."]
    pub end: *mut u8,
    pub decode: pt_config__bindgen_ty_1,
    #[doc = " The cpu on which Intel PT has been recorded."]
    pub cpu: pt_cpu,
    #[doc = " The errata to apply when encoding or decoding Intel PT."]
    pub errata: pt_errata,
    pub cpuid_0x15_eax: u32,
    pub cpuid_0x15_ebx: u32,
    pub mtc_freq: u8,
    pub nom_freq: u8,
    #[doc = " A collection of decoder-specific flags."]
    pub flags: pt_conf_flags,
    #[doc = " The address filter configuration."]
    pub addr_filter: pt_conf_addr_filter,
}
#[doc = " An optional callback for handling unknown packets."]
#[doc = ""]
#[doc = " If \\@callback is not NULL, it is called for any unknown opcode."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_config__bindgen_ty_1 {
    #[doc = " The callback function."]
    #[doc = ""]
    #[doc = " It shall decode the packet at \\@pos into \\@unknown."]
    #[doc = " It shall return the number of bytes read upon success."]
    #[doc = " It shall return a negative pt_error_code otherwise."]
    #[doc = " The below context is passed as \\@context."]
    pub callback: ::std::option::Option<
        unsafe extern "C" fn(
            unknown: *mut pt_packet_unknown,
            config: *const pt_config,
            pos: *const u8,
            context: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " The user-defined context for this configuration."]
    pub context: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_pt_config__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pt_config__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(pt_config__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_config__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_config__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_config__bindgen_ty_1>())).callback as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_config__bindgen_ty_1),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_config__bindgen_ty_1>())).context as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_config__bindgen_ty_1),
            "::",
            stringify!(context)
        )
    );
}
#[test]
fn bindgen_test_layout_pt_config() {
    assert_eq!(
        ::std::mem::size_of::<pt_config>(),
        280usize,
        concat!("Size of: ", stringify!(pt_config))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_config>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_config))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_config>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_config),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_config>())).begin as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_config),
            "::",
            stringify!(begin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_config>())).end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_config),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_config>())).decode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_config),
            "::",
            stringify!(decode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_config>())).cpu as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_config),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_config>())).errata as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_config),
            "::",
            stringify!(errata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_config>())).cpuid_0x15_eax as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_config),
            "::",
            stringify!(cpuid_0x15_eax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_config>())).cpuid_0x15_ebx as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_config),
            "::",
            stringify!(cpuid_0x15_ebx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_config>())).mtc_freq as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_config),
            "::",
            stringify!(mtc_freq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_config>())).nom_freq as *const _ as usize },
        121usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_config),
            "::",
            stringify!(nom_freq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_config>())).flags as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_config),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_config>())).addr_filter as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_config),
            "::",
            stringify!(addr_filter)
        )
    );
}
extern "C" {
    #[doc = " Determine errata for a given cpu."]
    #[doc = ""]
    #[doc = " Updates \\@errata based on \\@cpu."]
    #[doc = ""]
    #[doc = " Returns 0 on success, a negative error code otherwise."]
    #[doc = " Returns -pte_invalid if \\@errata or \\@cpu is NULL."]
    #[doc = " Returns -pte_bad_cpu if \\@cpu is not known."]
    pub fn pt_cpu_errata(errata: *mut pt_errata, cpu: *const pt_cpu) -> ::std::os::raw::c_int;
}
pub const pt_packet_type_ppt_invalid: pt_packet_type = 0;
pub const pt_packet_type_ppt_unknown: pt_packet_type = 1;
pub const pt_packet_type_ppt_pad: pt_packet_type = 2;
pub const pt_packet_type_ppt_psb: pt_packet_type = 3;
pub const pt_packet_type_ppt_psbend: pt_packet_type = 4;
pub const pt_packet_type_ppt_fup: pt_packet_type = 5;
pub const pt_packet_type_ppt_tip: pt_packet_type = 6;
pub const pt_packet_type_ppt_tip_pge: pt_packet_type = 7;
pub const pt_packet_type_ppt_tip_pgd: pt_packet_type = 8;
pub const pt_packet_type_ppt_tnt_8: pt_packet_type = 9;
pub const pt_packet_type_ppt_tnt_64: pt_packet_type = 10;
pub const pt_packet_type_ppt_mode: pt_packet_type = 11;
pub const pt_packet_type_ppt_pip: pt_packet_type = 12;
pub const pt_packet_type_ppt_vmcs: pt_packet_type = 13;
pub const pt_packet_type_ppt_cbr: pt_packet_type = 14;
pub const pt_packet_type_ppt_tsc: pt_packet_type = 15;
pub const pt_packet_type_ppt_tma: pt_packet_type = 16;
pub const pt_packet_type_ppt_mtc: pt_packet_type = 17;
pub const pt_packet_type_ppt_cyc: pt_packet_type = 18;
pub const pt_packet_type_ppt_stop: pt_packet_type = 19;
pub const pt_packet_type_ppt_ovf: pt_packet_type = 20;
pub const pt_packet_type_ppt_mnt: pt_packet_type = 21;
pub const pt_packet_type_ppt_exstop: pt_packet_type = 22;
pub const pt_packet_type_ppt_mwait: pt_packet_type = 23;
pub const pt_packet_type_ppt_pwre: pt_packet_type = 24;
pub const pt_packet_type_ppt_pwrx: pt_packet_type = 25;
pub const pt_packet_type_ppt_ptw: pt_packet_type = 26;
#[doc = " Intel PT packet types."]
pub type pt_packet_type = i32;
pub const pt_ip_compression_pt_ipc_suppressed: pt_ip_compression = 0;
pub const pt_ip_compression_pt_ipc_update_16: pt_ip_compression = 1;
pub const pt_ip_compression_pt_ipc_update_32: pt_ip_compression = 2;
pub const pt_ip_compression_pt_ipc_sext_48: pt_ip_compression = 3;
pub const pt_ip_compression_pt_ipc_update_48: pt_ip_compression = 4;
pub const pt_ip_compression_pt_ipc_full: pt_ip_compression = 6;
#[doc = " The IP compression."]
pub type pt_ip_compression = i32;
pub const pt_exec_mode_ptem_unknown: pt_exec_mode = 0;
pub const pt_exec_mode_ptem_16bit: pt_exec_mode = 1;
pub const pt_exec_mode_ptem_32bit: pt_exec_mode = 2;
pub const pt_exec_mode_ptem_64bit: pt_exec_mode = 3;
#[doc = " An execution mode."]
pub type pt_exec_mode = i32;
pub const pt_mode_leaf_pt_mol_exec: pt_mode_leaf = 0;
pub const pt_mode_leaf_pt_mol_tsx: pt_mode_leaf = 32;
#[doc = " Mode packet leaves."]
pub type pt_mode_leaf = i32;
#[doc = " A TNT-8 or TNT-64 packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_tnt {
    #[doc = " TNT payload bit size."]
    pub bit_size: u8,
    #[doc = " TNT payload excluding stop bit."]
    pub payload: u64,
}
#[test]
fn bindgen_test_layout_pt_packet_tnt() {
    assert_eq!(
        ::std::mem::size_of::<pt_packet_tnt>(),
        16usize,
        concat!("Size of: ", stringify!(pt_packet_tnt))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_packet_tnt>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_packet_tnt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet_tnt>())).bit_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_tnt),
            "::",
            stringify!(bit_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet_tnt>())).payload as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_tnt),
            "::",
            stringify!(payload)
        )
    );
}
#[doc = " A packet with IP payload."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_ip {
    #[doc = " IP compression."]
    pub ipc: pt_ip_compression,
    #[doc = " Zero-extended payload ip."]
    pub ip: u64,
}
#[test]
fn bindgen_test_layout_pt_packet_ip() {
    assert_eq!(
        ::std::mem::size_of::<pt_packet_ip>(),
        16usize,
        concat!("Size of: ", stringify!(pt_packet_ip))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_packet_ip>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_packet_ip))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet_ip>())).ipc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_ip),
            "::",
            stringify!(ipc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet_ip>())).ip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_ip),
            "::",
            stringify!(ip)
        )
    );
}
#[doc = " A mode.exec packet."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_mode_exec {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_pt_packet_mode_exec() {
    assert_eq!(
        ::std::mem::size_of::<pt_packet_mode_exec>(),
        4usize,
        concat!("Size of: ", stringify!(pt_packet_mode_exec))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_packet_mode_exec>(),
        4usize,
        concat!("Alignment of ", stringify!(pt_packet_mode_exec))
    );
}
impl pt_packet_mode_exec {
    #[inline]
    pub fn csl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_csl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csd(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_csd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(csl: u32, csd: u32) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let csl: u32 = unsafe { ::std::mem::transmute(csl) };
            csl as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let csd: u32 = unsafe { ::std::mem::transmute(csd) };
            csd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A mode.tsx packet."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_mode_tsx {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_pt_packet_mode_tsx() {
    assert_eq!(
        ::std::mem::size_of::<pt_packet_mode_tsx>(),
        4usize,
        concat!("Size of: ", stringify!(pt_packet_mode_tsx))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_packet_mode_tsx>(),
        4usize,
        concat!("Alignment of ", stringify!(pt_packet_mode_tsx))
    );
}
impl pt_packet_mode_tsx {
    #[inline]
    pub fn intx(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_intx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn abrt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_abrt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intx: u32, abrt: u32) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let intx: u32 = unsafe { ::std::mem::transmute(intx) };
            intx as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let abrt: u32 = unsafe { ::std::mem::transmute(abrt) };
            abrt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A mode packet."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pt_packet_mode {
    #[doc = " Mode leaf."]
    pub leaf: pt_mode_leaf,
    pub bits: pt_packet_mode__bindgen_ty_1,
}
#[doc = " Mode bits."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union pt_packet_mode__bindgen_ty_1 {
    #[doc = " Packet: mode.exec."]
    pub exec: pt_packet_mode_exec,
    #[doc = " Packet: mode.tsx."]
    pub tsx: pt_packet_mode_tsx,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pt_packet_mode__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pt_packet_mode__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(pt_packet_mode__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_packet_mode__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(pt_packet_mode__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_packet_mode__bindgen_ty_1>())).exec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_mode__bindgen_ty_1),
            "::",
            stringify!(exec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_packet_mode__bindgen_ty_1>())).tsx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_mode__bindgen_ty_1),
            "::",
            stringify!(tsx)
        )
    );
}
#[test]
fn bindgen_test_layout_pt_packet_mode() {
    assert_eq!(
        ::std::mem::size_of::<pt_packet_mode>(),
        8usize,
        concat!("Size of: ", stringify!(pt_packet_mode))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_packet_mode>(),
        4usize,
        concat!("Alignment of ", stringify!(pt_packet_mode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet_mode>())).leaf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_mode),
            "::",
            stringify!(leaf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet_mode>())).bits as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_mode),
            "::",
            stringify!(bits)
        )
    );
}
#[doc = " A PIP packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_pip {
    #[doc = " The CR3 value."]
    pub cr3: u64,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_pt_packet_pip() {
    assert_eq!(
        ::std::mem::size_of::<pt_packet_pip>(),
        16usize,
        concat!("Size of: ", stringify!(pt_packet_pip))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_packet_pip>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_packet_pip))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet_pip>())).cr3 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_pip),
            "::",
            stringify!(cr3)
        )
    );
}
impl pt_packet_pip {
    #[inline]
    pub fn nr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(nr: u32) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let nr: u32 = unsafe { ::std::mem::transmute(nr) };
            nr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A TSC packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_tsc {
    #[doc = " The TSC value."]
    pub tsc: u64,
}
#[test]
fn bindgen_test_layout_pt_packet_tsc() {
    assert_eq!(
        ::std::mem::size_of::<pt_packet_tsc>(),
        8usize,
        concat!("Size of: ", stringify!(pt_packet_tsc))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_packet_tsc>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_packet_tsc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet_tsc>())).tsc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_tsc),
            "::",
            stringify!(tsc)
        )
    );
}
#[doc = " A CBR packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_cbr {
    #[doc = " The core/bus cycle ratio."]
    pub ratio: u8,
}
#[test]
fn bindgen_test_layout_pt_packet_cbr() {
    assert_eq!(
        ::std::mem::size_of::<pt_packet_cbr>(),
        1usize,
        concat!("Size of: ", stringify!(pt_packet_cbr))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_packet_cbr>(),
        1usize,
        concat!("Alignment of ", stringify!(pt_packet_cbr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet_cbr>())).ratio as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_cbr),
            "::",
            stringify!(ratio)
        )
    );
}
#[doc = " A TMA packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_tma {
    #[doc = " The crystal clock tick counter value."]
    pub ctc: u16,
    #[doc = " The fast counter value."]
    pub fc: u16,
}
#[test]
fn bindgen_test_layout_pt_packet_tma() {
    assert_eq!(
        ::std::mem::size_of::<pt_packet_tma>(),
        4usize,
        concat!("Size of: ", stringify!(pt_packet_tma))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_packet_tma>(),
        2usize,
        concat!("Alignment of ", stringify!(pt_packet_tma))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet_tma>())).ctc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_tma),
            "::",
            stringify!(ctc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet_tma>())).fc as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_tma),
            "::",
            stringify!(fc)
        )
    );
}
#[doc = " A MTC packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_mtc {
    #[doc = " The crystal clock tick counter value."]
    pub ctc: u8,
}
#[test]
fn bindgen_test_layout_pt_packet_mtc() {
    assert_eq!(
        ::std::mem::size_of::<pt_packet_mtc>(),
        1usize,
        concat!("Size of: ", stringify!(pt_packet_mtc))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_packet_mtc>(),
        1usize,
        concat!("Alignment of ", stringify!(pt_packet_mtc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet_mtc>())).ctc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_mtc),
            "::",
            stringify!(ctc)
        )
    );
}
#[doc = " A CYC packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_cyc {
    #[doc = " The cycle counter value."]
    pub value: u64,
}
#[test]
fn bindgen_test_layout_pt_packet_cyc() {
    assert_eq!(
        ::std::mem::size_of::<pt_packet_cyc>(),
        8usize,
        concat!("Size of: ", stringify!(pt_packet_cyc))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_packet_cyc>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_packet_cyc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet_cyc>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_cyc),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " A VMCS packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_vmcs {
    pub base: u64,
}
#[test]
fn bindgen_test_layout_pt_packet_vmcs() {
    assert_eq!(
        ::std::mem::size_of::<pt_packet_vmcs>(),
        8usize,
        concat!("Size of: ", stringify!(pt_packet_vmcs))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_packet_vmcs>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_packet_vmcs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet_vmcs>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_vmcs),
            "::",
            stringify!(base)
        )
    );
}
#[doc = " A MNT packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_mnt {
    #[doc = " The raw payload."]
    pub payload: u64,
}
#[test]
fn bindgen_test_layout_pt_packet_mnt() {
    assert_eq!(
        ::std::mem::size_of::<pt_packet_mnt>(),
        8usize,
        concat!("Size of: ", stringify!(pt_packet_mnt))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_packet_mnt>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_packet_mnt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet_mnt>())).payload as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_mnt),
            "::",
            stringify!(payload)
        )
    );
}
#[doc = " A EXSTOP packet."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_exstop {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_pt_packet_exstop() {
    assert_eq!(
        ::std::mem::size_of::<pt_packet_exstop>(),
        4usize,
        concat!("Size of: ", stringify!(pt_packet_exstop))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_packet_exstop>(),
        4usize,
        concat!("Alignment of ", stringify!(pt_packet_exstop))
    );
}
impl pt_packet_exstop {
    #[inline]
    pub fn ip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ip: u32) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ip: u32 = unsafe { ::std::mem::transmute(ip) };
            ip as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A MWAIT packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_mwait {
    #[doc = " The MWAIT hints (EAX)."]
    pub hints: u32,
    #[doc = " The MWAIT extensions (ECX)."]
    pub ext: u32,
}
#[test]
fn bindgen_test_layout_pt_packet_mwait() {
    assert_eq!(
        ::std::mem::size_of::<pt_packet_mwait>(),
        8usize,
        concat!("Size of: ", stringify!(pt_packet_mwait))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_packet_mwait>(),
        4usize,
        concat!("Alignment of ", stringify!(pt_packet_mwait))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet_mwait>())).hints as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_mwait),
            "::",
            stringify!(hints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet_mwait>())).ext as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_mwait),
            "::",
            stringify!(ext)
        )
    );
}
#[doc = " A PWRE packet."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_pwre {
    #[doc = " The resolved thread C-state."]
    pub state: u8,
    #[doc = " The resolved thread sub C-state."]
    pub sub_state: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 5usize],
}
#[test]
fn bindgen_test_layout_pt_packet_pwre() {
    assert_eq!(
        ::std::mem::size_of::<pt_packet_pwre>(),
        8usize,
        concat!("Size of: ", stringify!(pt_packet_pwre))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_packet_pwre>(),
        4usize,
        concat!("Alignment of ", stringify!(pt_packet_pwre))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet_pwre>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_pwre),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet_pwre>())).sub_state as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_pwre),
            "::",
            stringify!(sub_state)
        )
    );
}
impl pt_packet_pwre {
    #[inline]
    pub fn hw(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(hw: u32) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hw: u32 = unsafe { ::std::mem::transmute(hw) };
            hw as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A PWRX packet."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_pwrx {
    #[doc = " The core C-state at the time of the wake."]
    pub last: u8,
    #[doc = " The deepest core C-state achieved during sleep."]
    pub deepest: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 5usize],
}
#[test]
fn bindgen_test_layout_pt_packet_pwrx() {
    assert_eq!(
        ::std::mem::size_of::<pt_packet_pwrx>(),
        8usize,
        concat!("Size of: ", stringify!(pt_packet_pwrx))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_packet_pwrx>(),
        4usize,
        concat!("Alignment of ", stringify!(pt_packet_pwrx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet_pwrx>())).last as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_pwrx),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet_pwrx>())).deepest as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_pwrx),
            "::",
            stringify!(deepest)
        )
    );
}
impl pt_packet_pwrx {
    #[inline]
    pub fn interrupt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_interrupt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn store(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_store(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autonomous(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_autonomous(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        interrupt: u32,
        store: u32,
        autonomous: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let interrupt: u32 = unsafe { ::std::mem::transmute(interrupt) };
            interrupt as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let store: u32 = unsafe { ::std::mem::transmute(store) };
            store as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let autonomous: u32 = unsafe { ::std::mem::transmute(autonomous) };
            autonomous as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A PTW packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_ptw {
    #[doc = " The raw payload."]
    pub payload: u64,
    #[doc = " The payload size as encoded in the packet."]
    pub plc: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u16; 3usize],
}
#[test]
fn bindgen_test_layout_pt_packet_ptw() {
    assert_eq!(
        ::std::mem::size_of::<pt_packet_ptw>(),
        16usize,
        concat!("Size of: ", stringify!(pt_packet_ptw))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_packet_ptw>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_packet_ptw))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet_ptw>())).payload as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_ptw),
            "::",
            stringify!(payload)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet_ptw>())).plc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_ptw),
            "::",
            stringify!(plc)
        )
    );
}
impl pt_packet_ptw {
    #[inline]
    pub fn ip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ip: u32) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ip: u32 = unsafe { ::std::mem::transmute(ip) };
            ip as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " An unknown packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_unknown {
    #[doc = " Pointer to the raw packet bytes."]
    pub packet: *const u8,
    #[doc = " Optional pointer to a user-defined structure."]
    pub priv_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_pt_packet_unknown() {
    assert_eq!(
        ::std::mem::size_of::<pt_packet_unknown>(),
        16usize,
        concat!("Size of: ", stringify!(pt_packet_unknown))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_packet_unknown>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_packet_unknown))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet_unknown>())).packet as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_unknown),
            "::",
            stringify!(packet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet_unknown>())).priv_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet_unknown),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " An Intel PT packet."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pt_packet {
    #[doc = " The type of the packet."]
    #[doc = ""]
    #[doc = " This also determines the \\@payload field."]
    pub type_: pt_packet_type,
    #[doc = " The size of the packet including opcode and payload."]
    pub size: u8,
    pub payload: pt_packet__bindgen_ty_1,
}
#[doc = " Packet specific data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union pt_packet__bindgen_ty_1 {
    #[doc = " Packet: tnt-8, tnt-64."]
    pub tnt: pt_packet_tnt,
    #[doc = " Packet: tip, fup, tip.pge, tip.pgd."]
    pub ip: pt_packet_ip,
    #[doc = " Packet: mode."]
    pub mode: pt_packet_mode,
    #[doc = " Packet: pip."]
    pub pip: pt_packet_pip,
    #[doc = " Packet: tsc."]
    pub tsc: pt_packet_tsc,
    #[doc = " Packet: cbr."]
    pub cbr: pt_packet_cbr,
    #[doc = " Packet: tma."]
    pub tma: pt_packet_tma,
    #[doc = " Packet: mtc."]
    pub mtc: pt_packet_mtc,
    #[doc = " Packet: cyc."]
    pub cyc: pt_packet_cyc,
    #[doc = " Packet: vmcs."]
    pub vmcs: pt_packet_vmcs,
    #[doc = " Packet: mnt."]
    pub mnt: pt_packet_mnt,
    #[doc = " Packet: exstop."]
    pub exstop: pt_packet_exstop,
    #[doc = " Packet: mwait."]
    pub mwait: pt_packet_mwait,
    #[doc = " Packet: pwre."]
    pub pwre: pt_packet_pwre,
    #[doc = " Packet: pwrx."]
    pub pwrx: pt_packet_pwrx,
    #[doc = " Packet: ptw."]
    pub ptw: pt_packet_ptw,
    #[doc = " Packet: unknown."]
    pub unknown: pt_packet_unknown,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_pt_packet__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pt_packet__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(pt_packet__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_packet__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_packet__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet__bindgen_ty_1>())).tnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet__bindgen_ty_1),
            "::",
            stringify!(tnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet__bindgen_ty_1>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet__bindgen_ty_1),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet__bindgen_ty_1>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet__bindgen_ty_1),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet__bindgen_ty_1>())).pip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet__bindgen_ty_1),
            "::",
            stringify!(pip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet__bindgen_ty_1>())).tsc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet__bindgen_ty_1),
            "::",
            stringify!(tsc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet__bindgen_ty_1>())).cbr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet__bindgen_ty_1),
            "::",
            stringify!(cbr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet__bindgen_ty_1>())).tma as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet__bindgen_ty_1),
            "::",
            stringify!(tma)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet__bindgen_ty_1>())).mtc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet__bindgen_ty_1),
            "::",
            stringify!(mtc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet__bindgen_ty_1>())).cyc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet__bindgen_ty_1),
            "::",
            stringify!(cyc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet__bindgen_ty_1>())).vmcs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet__bindgen_ty_1),
            "::",
            stringify!(vmcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet__bindgen_ty_1>())).mnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet__bindgen_ty_1),
            "::",
            stringify!(mnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet__bindgen_ty_1>())).exstop as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet__bindgen_ty_1),
            "::",
            stringify!(exstop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet__bindgen_ty_1>())).mwait as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet__bindgen_ty_1),
            "::",
            stringify!(mwait)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet__bindgen_ty_1>())).pwre as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet__bindgen_ty_1),
            "::",
            stringify!(pwre)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet__bindgen_ty_1>())).pwrx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet__bindgen_ty_1),
            "::",
            stringify!(pwrx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet__bindgen_ty_1>())).ptw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet__bindgen_ty_1),
            "::",
            stringify!(ptw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet__bindgen_ty_1>())).unknown as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet__bindgen_ty_1),
            "::",
            stringify!(unknown)
        )
    );
}
#[test]
fn bindgen_test_layout_pt_packet() {
    assert_eq!(
        ::std::mem::size_of::<pt_packet>(),
        24usize,
        concat!("Size of: ", stringify!(pt_packet))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_packet>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_packet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_packet>())).payload as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_packet),
            "::",
            stringify!(payload)
        )
    );
}
extern "C" {
    #[doc = " Allocate an Intel PT packet encoder."]
    #[doc = ""]
    #[doc = " The encoder will work on the buffer defined in \\@config, it shall contain"]
    #[doc = " raw trace data and remain valid for the lifetime of the encoder."]
    #[doc = ""]
    #[doc = " The encoder starts at the beginning of the trace buffer."]
    pub fn pt_alloc_encoder(config: *const pt_config) -> *mut pt_encoder;
}
extern "C" {
    #[doc = " Free an Intel PT packet encoder."]
    #[doc = ""]
    #[doc = " The \\@encoder must not be used after a successful return."]
    pub fn pt_free_encoder(encoder: *mut pt_encoder);
}
extern "C" {
    #[doc = " Hard set synchronization point of an Intel PT packet encoder."]
    #[doc = ""]
    #[doc = " Synchronize \\@encoder to \\@offset within the trace buffer."]
    #[doc = ""]
    #[doc = " Returns zero on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_eos if the given offset is behind the end of the trace buffer."]
    #[doc = " Returns -pte_invalid if \\@encoder is NULL."]
    pub fn pt_enc_sync_set(encoder: *mut pt_encoder, offset: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current packet encoder position."]
    #[doc = ""]
    #[doc = " Fills the current \\@encoder position into \\@offset."]
    #[doc = ""]
    #[doc = " This is useful for reporting errors."]
    #[doc = ""]
    #[doc = " Returns zero on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_invalid if \\@encoder or \\@offset is NULL."]
    pub fn pt_enc_get_offset(encoder: *const pt_encoder, offset: *mut u64)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pt_enc_get_config(encoder: *const pt_encoder) -> *const pt_config;
}
extern "C" {
    #[doc = " Encode an Intel PT packet."]
    #[doc = ""]
    #[doc = " Writes \\@packet at \\@encoder's current position in the Intel PT buffer and"]
    #[doc = " advances the \\@encoder beyond the written packet."]
    #[doc = ""]
    #[doc = " The \\@packet.size field is ignored."]
    #[doc = ""]
    #[doc = " In case of errors, the \\@encoder is not advanced and nothing is written"]
    #[doc = " into the Intel PT buffer."]
    #[doc = ""]
    #[doc = " Returns the number of bytes written on success, a negative error code"]
    #[doc = " otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_bad_opc if \\@packet.type is not known."]
    #[doc = " Returns -pte_bad_packet if \\@packet's payload is invalid."]
    #[doc = " Returns -pte_eos if \\@encoder reached the end of the Intel PT buffer."]
    #[doc = " Returns -pte_invalid if \\@encoder or \\@packet is NULL."]
    pub fn pt_enc_next(encoder: *mut pt_encoder, packet: *const pt_packet)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate an Intel PT packet decoder."]
    #[doc = ""]
    #[doc = " The decoder will work on the buffer defined in \\@config, it shall contain"]
    #[doc = " raw trace data and remain valid for the lifetime of the decoder."]
    #[doc = ""]
    #[doc = " The decoder needs to be synchronized before it can be used."]
    pub fn pt_pkt_alloc_decoder(config: *const pt_config) -> *mut pt_packet_decoder;
}
extern "C" {
    #[doc = " Free an Intel PT packet decoder."]
    #[doc = ""]
    #[doc = " The \\@decoder must not be used after a successful return."]
    pub fn pt_pkt_free_decoder(decoder: *mut pt_packet_decoder);
}
extern "C" {
    #[doc = " Synchronize an Intel PT packet decoder."]
    #[doc = ""]
    #[doc = " Search for the next synchronization point in forward or backward direction."]
    #[doc = ""]
    #[doc = " If \\@decoder has not been synchronized, yet, the search is started at the"]
    #[doc = " beginning of the trace buffer in case of forward synchronization and at the"]
    #[doc = " end of the trace buffer in case of backward synchronization."]
    #[doc = ""]
    #[doc = " Returns zero or a positive value on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_eos if no further synchronization point is found."]
    #[doc = " Returns -pte_invalid if \\@decoder is NULL."]
    pub fn pt_pkt_sync_forward(decoder: *mut pt_packet_decoder) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pt_pkt_sync_backward(decoder: *mut pt_packet_decoder) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Hard set synchronization point of an Intel PT decoder."]
    #[doc = ""]
    #[doc = " Synchronize \\@decoder to \\@offset within the trace buffer."]
    #[doc = ""]
    #[doc = " Returns zero on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_eos if the given offset is behind the end of the trace buffer."]
    #[doc = " Returns -pte_invalid if \\@decoder is NULL."]
    pub fn pt_pkt_sync_set(decoder: *mut pt_packet_decoder, offset: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current decoder position."]
    #[doc = ""]
    #[doc = " Fills the current \\@decoder position into \\@offset."]
    #[doc = ""]
    #[doc = " This is useful for reporting errors."]
    #[doc = ""]
    #[doc = " Returns zero on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_invalid if \\@decoder or \\@offset is NULL."]
    #[doc = " Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_pkt_get_offset(
        decoder: *const pt_packet_decoder,
        offset: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the position of the last synchronization point."]
    #[doc = ""]
    #[doc = " Fills the last synchronization position into \\@offset."]
    #[doc = ""]
    #[doc = " This is useful when splitting a trace stream for parallel decoding."]
    #[doc = ""]
    #[doc = " Returns zero on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_invalid if \\@decoder or \\@offset is NULL."]
    #[doc = " Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_pkt_get_sync_offset(
        decoder: *const pt_packet_decoder,
        offset: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pt_pkt_get_config(decoder: *const pt_packet_decoder) -> *const pt_config;
}
extern "C" {
    #[doc = " Decode the next packet and advance the decoder."]
    #[doc = ""]
    #[doc = " Decodes the packet at \\@decoder's current position into \\@packet and"]
    #[doc = " adjusts the \\@decoder's position by the number of bytes the packet had"]
    #[doc = " consumed."]
    #[doc = ""]
    #[doc = " The \\@size argument must be set to sizeof(struct pt_packet)."]
    #[doc = ""]
    #[doc = " Returns the number of bytes consumed on success, a negative error code"]
    #[doc = " otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_bad_opc if the packet is unknown."]
    #[doc = " Returns -pte_bad_packet if an unknown packet payload is encountered."]
    #[doc = " Returns -pte_eos if \\@decoder reached the end of the Intel PT buffer."]
    #[doc = " Returns -pte_invalid if \\@decoder or \\@packet is NULL."]
    #[doc = " Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_pkt_next(
        decoder: *mut pt_packet_decoder,
        packet: *mut pt_packet,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " There is an event pending."]
pub const pt_status_flag_pts_event_pending: pt_status_flag = 1;
#[doc = " The address has been suppressed."]
pub const pt_status_flag_pts_ip_suppressed: pt_status_flag = 2;
#[doc = " There is no more trace data available."]
pub const pt_status_flag_pts_eos: pt_status_flag = 4;
#[doc = " Decoder status flags."]
pub type pt_status_flag = i32;
pub const pt_event_type_ptev_enabled: pt_event_type = 0;
pub const pt_event_type_ptev_disabled: pt_event_type = 1;
pub const pt_event_type_ptev_async_disabled: pt_event_type = 2;
pub const pt_event_type_ptev_async_branch: pt_event_type = 3;
pub const pt_event_type_ptev_paging: pt_event_type = 4;
pub const pt_event_type_ptev_async_paging: pt_event_type = 5;
pub const pt_event_type_ptev_overflow: pt_event_type = 6;
pub const pt_event_type_ptev_exec_mode: pt_event_type = 7;
pub const pt_event_type_ptev_tsx: pt_event_type = 8;
pub const pt_event_type_ptev_stop: pt_event_type = 9;
pub const pt_event_type_ptev_vmcs: pt_event_type = 10;
pub const pt_event_type_ptev_async_vmcs: pt_event_type = 11;
pub const pt_event_type_ptev_exstop: pt_event_type = 12;
pub const pt_event_type_ptev_mwait: pt_event_type = 13;
pub const pt_event_type_ptev_pwre: pt_event_type = 14;
pub const pt_event_type_ptev_pwrx: pt_event_type = 15;
pub const pt_event_type_ptev_ptwrite: pt_event_type = 16;
pub const pt_event_type_ptev_tick: pt_event_type = 17;
pub const pt_event_type_ptev_cbr: pt_event_type = 18;
pub const pt_event_type_ptev_mnt: pt_event_type = 19;
#[doc = " Event types."]
pub type pt_event_type = i32;
#[doc = " An event."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pt_event {
    #[doc = " The type of the event."]
    pub type_: pt_event_type,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = " The time stamp count of the event."]
    #[doc = ""]
    #[doc = " This field is only valid if \\@has_tsc is set."]
    pub tsc: u64,
    #[doc = " The number of lost mtc and cyc packets."]
    #[doc = ""]
    #[doc = " This gives an idea about the quality of the \\@tsc.  The more packets"]
    #[doc = " were dropped, the less precise timing is."]
    pub lost_mtc: u32,
    pub lost_cyc: u32,
    pub reserved: [u64; 2usize],
    pub variant: pt_event__bindgen_ty_1,
}
#[doc = " Event specific data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union pt_event__bindgen_ty_1 {
    pub enabled: pt_event__bindgen_ty_1__bindgen_ty_1,
    pub disabled: pt_event__bindgen_ty_1__bindgen_ty_2,
    pub async_disabled: pt_event__bindgen_ty_1__bindgen_ty_3,
    pub async_branch: pt_event__bindgen_ty_1__bindgen_ty_4,
    pub paging: pt_event__bindgen_ty_1__bindgen_ty_5,
    pub async_paging: pt_event__bindgen_ty_1__bindgen_ty_6,
    pub overflow: pt_event__bindgen_ty_1__bindgen_ty_7,
    pub exec_mode: pt_event__bindgen_ty_1__bindgen_ty_8,
    pub tsx: pt_event__bindgen_ty_1__bindgen_ty_9,
    pub vmcs: pt_event__bindgen_ty_1__bindgen_ty_10,
    pub async_vmcs: pt_event__bindgen_ty_1__bindgen_ty_11,
    pub exstop: pt_event__bindgen_ty_1__bindgen_ty_12,
    pub mwait: pt_event__bindgen_ty_1__bindgen_ty_13,
    pub pwre: pt_event__bindgen_ty_1__bindgen_ty_14,
    pub pwrx: pt_event__bindgen_ty_1__bindgen_ty_15,
    pub ptwrite: pt_event__bindgen_ty_1__bindgen_ty_16,
    pub tick: pt_event__bindgen_ty_1__bindgen_ty_17,
    pub cbr: pt_event__bindgen_ty_1__bindgen_ty_18,
    pub mnt: pt_event__bindgen_ty_1__bindgen_ty_19,
    _bindgen_union_align: [u64; 3usize],
}
#[doc = " Event: enabled."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " The address at which tracing resumes."]
    pub ip: u64,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_pt_event__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_1>())).ip as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ip)
        )
    );
}
impl pt_event__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn resumed(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_resumed(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(resumed: u32) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let resumed: u32 = unsafe { ::std::mem::transmute(resumed) };
            resumed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Event: disabled."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " The destination of the first branch inside a"]
    #[doc = " filtered area."]
    #[doc = ""]
    #[doc = " This field is not valid if \\@ip_suppressed is set."]
    pub ip: u64,
}
#[test]
fn bindgen_test_layout_pt_event__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_2>())).ip as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(ip)
        )
    );
}
#[doc = " Event: async disabled."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " The source address of the asynchronous branch that"]
    #[doc = " disabled tracing."]
    pub at: u64,
    #[doc = " The destination of the first branch inside a"]
    #[doc = " filtered area."]
    #[doc = ""]
    #[doc = " This field is not valid if \\@ip_suppressed is set."]
    pub ip: u64,
}
#[test]
fn bindgen_test_layout_pt_event__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_3>())).at as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(at)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_3>())).ip as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(ip)
        )
    );
}
#[doc = " Event: async branch."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_4 {
    #[doc = " The branch source address."]
    pub from: u64,
    #[doc = " The branch destination address."]
    #[doc = ""]
    #[doc = " This field is not valid if \\@ip_suppressed is set."]
    pub to: u64,
}
#[test]
fn bindgen_test_layout_pt_event__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_4>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_4>())).from as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_4>())).to as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(to)
        )
    );
}
#[doc = " Event: paging."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_5 {
    #[doc = " The updated CR3 value."]
    #[doc = ""]
    #[doc = " The lower 5 bit have been zeroed out."]
    #[doc = " The upper bits have been zeroed out depending on the"]
    #[doc = " maximum possible address."]
    pub cr3: u64,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_pt_event__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_5>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_5>())).cr3 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(cr3)
        )
    );
}
impl pt_event__bindgen_ty_1__bindgen_ty_5 {
    #[inline]
    pub fn non_root(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_non_root(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(non_root: u32) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let non_root: u32 = unsafe { ::std::mem::transmute(non_root) };
            non_root as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Event: async paging."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_6 {
    #[doc = " The updated CR3 value."]
    #[doc = ""]
    #[doc = " The lower 5 bit have been zeroed out."]
    #[doc = " The upper bits have been zeroed out depending on the"]
    #[doc = " maximum possible address."]
    pub cr3: u64,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = " The address at which the event is effective."]
    pub ip: u64,
}
#[test]
fn bindgen_test_layout_pt_event__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_6>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_6>())).cr3 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(cr3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_6>())).ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(ip)
        )
    );
}
impl pt_event__bindgen_ty_1__bindgen_ty_6 {
    #[inline]
    pub fn non_root(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_non_root(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(non_root: u32) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let non_root: u32 = unsafe { ::std::mem::transmute(non_root) };
            non_root as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Event: overflow."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_7 {
    #[doc = " The address at which tracing resumes after overflow."]
    #[doc = ""]
    #[doc = " This field is not valid, if ip_suppressed is set."]
    #[doc = " In this case, the overflow resolved while tracing"]
    #[doc = " was disabled."]
    pub ip: u64,
}
#[test]
fn bindgen_test_layout_pt_event__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_7>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_7>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_7>())).ip as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(ip)
        )
    );
}
#[doc = " Event: exec mode."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_8 {
    #[doc = " The execution mode."]
    pub mode: pt_exec_mode,
    #[doc = " The address at which the event is effective."]
    pub ip: u64,
}
#[test]
fn bindgen_test_layout_pt_event__bindgen_ty_1__bindgen_ty_8() {
    assert_eq!(
        ::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_8>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_8)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_8>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_8>())).mode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_8>())).ip as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(ip)
        )
    );
}
#[doc = " Event: tsx."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_9 {
    #[doc = " The address at which the event is effective."]
    #[doc = ""]
    #[doc = " This field is not valid if \\@ip_suppressed is set."]
    pub ip: u64,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_pt_event__bindgen_ty_1__bindgen_ty_9() {
    assert_eq!(
        ::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_9>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_9)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_9>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_9>())).ip as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(ip)
        )
    );
}
impl pt_event__bindgen_ty_1__bindgen_ty_9 {
    #[inline]
    pub fn speculative(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_speculative(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aborted(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aborted(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        speculative: u32,
        aborted: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let speculative: u32 = unsafe { ::std::mem::transmute(speculative) };
            speculative as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let aborted: u32 = unsafe { ::std::mem::transmute(aborted) };
            aborted as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Event: vmcs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_10 {
    #[doc = " The VMCS base address."]
    #[doc = ""]
    #[doc = " The address is zero-extended with the lower 12 bits"]
    #[doc = " all zero."]
    pub base: u64,
}
#[test]
fn bindgen_test_layout_pt_event__bindgen_ty_1__bindgen_ty_10() {
    assert_eq!(
        ::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_10>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_10)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_10>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_10>())).base as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(base)
        )
    );
}
#[doc = " Event: async vmcs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_11 {
    #[doc = " The VMCS base address."]
    #[doc = ""]
    #[doc = " The address is zero-extended with the lower 12 bits"]
    #[doc = " all zero."]
    pub base: u64,
    #[doc = " The address at which the event is effective."]
    pub ip: u64,
}
#[test]
fn bindgen_test_layout_pt_event__bindgen_ty_1__bindgen_ty_11() {
    assert_eq!(
        ::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_11>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_11)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_11>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_11>())).base as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_11>())).ip as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(ip)
        )
    );
}
#[doc = " Event: execution stopped."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_12 {
    #[doc = " The address at which execution has stopped.  This is"]
    #[doc = " the last instruction that did not complete."]
    #[doc = ""]
    #[doc = " This field is not valid, if \\@ip_suppressed is set."]
    pub ip: u64,
}
#[test]
fn bindgen_test_layout_pt_event__bindgen_ty_1__bindgen_ty_12() {
    assert_eq!(
        ::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_12>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_12)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_12>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_12>())).ip as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(ip)
        )
    );
}
#[doc = " Event: mwait."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_13 {
    #[doc = " The address of the instruction causing the mwait."]
    #[doc = ""]
    #[doc = " This field is not valid, if \\@ip_suppressed is set."]
    pub ip: u64,
    #[doc = " The mwait hints (eax)."]
    #[doc = ""]
    #[doc = " Reserved bits are undefined."]
    pub hints: u32,
    #[doc = " The mwait extensions (ecx)."]
    #[doc = ""]
    #[doc = " Reserved bits are undefined."]
    pub ext: u32,
}
#[test]
fn bindgen_test_layout_pt_event__bindgen_ty_1__bindgen_ty_13() {
    assert_eq!(
        ::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_13>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_13)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_13>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_13>())).ip as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_13>())).hints as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(hints)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_13>())).ext as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(ext)
        )
    );
}
#[doc = " Event: power state entry."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_14 {
    #[doc = " The resolved thread C-state."]
    pub state: u8,
    #[doc = " The resolved thread sub C-state."]
    pub sub_state: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 5usize],
}
#[test]
fn bindgen_test_layout_pt_event__bindgen_ty_1__bindgen_ty_14() {
    assert_eq!(
        ::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_14>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_14)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_14>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_14>())).state as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_14>())).sub_state as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(sub_state)
        )
    );
}
impl pt_event__bindgen_ty_1__bindgen_ty_14 {
    #[inline]
    pub fn hw(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(hw: u32) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hw: u32 = unsafe { ::std::mem::transmute(hw) };
            hw as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Event: power state exit."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_15 {
    #[doc = " The core C-state at the time of the wake."]
    pub last: u8,
    #[doc = " The deepest core C-state achieved during sleep."]
    pub deepest: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 5usize],
}
#[test]
fn bindgen_test_layout_pt_event__bindgen_ty_1__bindgen_ty_15() {
    assert_eq!(
        ::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_15>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_15)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_15>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_15>())).last as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_15),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_15>())).deepest as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_15),
            "::",
            stringify!(deepest)
        )
    );
}
impl pt_event__bindgen_ty_1__bindgen_ty_15 {
    #[inline]
    pub fn interrupt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_interrupt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn store(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_store(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autonomous(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_autonomous(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        interrupt: u32,
        store: u32,
        autonomous: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let interrupt: u32 = unsafe { ::std::mem::transmute(interrupt) };
            interrupt as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let store: u32 = unsafe { ::std::mem::transmute(store) };
            store as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let autonomous: u32 = unsafe { ::std::mem::transmute(autonomous) };
            autonomous as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Event: ptwrite."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_16 {
    #[doc = " The address of the ptwrite instruction."]
    #[doc = ""]
    #[doc = " This field is not valid, if \\@ip_suppressed is set."]
    #[doc = ""]
    #[doc = " In this case, the address is obvious from the"]
    #[doc = " disassembly."]
    pub ip: u64,
    #[doc = " The size of the below \\@payload in bytes."]
    pub size: u8,
    #[doc = " The ptwrite payload."]
    pub payload: u64,
}
#[test]
fn bindgen_test_layout_pt_event__bindgen_ty_1__bindgen_ty_16() {
    assert_eq!(
        ::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_16>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_16)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_16>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_16>())).ip as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_16),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_16>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_16),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_16>())).payload as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_16),
            "::",
            stringify!(payload)
        )
    );
}
#[doc = " Event: tick."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_17 {
    #[doc = " The instruction address near which the tick occured."]
    #[doc = ""]
    #[doc = " A timestamp can sometimes be attributed directly to"]
    #[doc = " an instruction (e.g. to an indirect branch that"]
    #[doc = " receives CYC + TIP) and sometimes not (e.g. MTC)."]
    #[doc = ""]
    #[doc = " This field is not valid, if \\@ip_suppressed is set."]
    pub ip: u64,
}
#[test]
fn bindgen_test_layout_pt_event__bindgen_ty_1__bindgen_ty_17() {
    assert_eq!(
        ::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_17>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_17)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_17>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_17)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_17>())).ip as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_17),
            "::",
            stringify!(ip)
        )
    );
}
#[doc = " Event: cbr."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_18 {
    #[doc = " The core:bus ratio."]
    pub ratio: u16,
}
#[test]
fn bindgen_test_layout_pt_event__bindgen_ty_1__bindgen_ty_18() {
    assert_eq!(
        ::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_18>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_18)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_18>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_18)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_18>())).ratio as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_18),
            "::",
            stringify!(ratio)
        )
    );
}
#[doc = " Event: mnt."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_19 {
    #[doc = " The raw payload."]
    pub payload: u64,
}
#[test]
fn bindgen_test_layout_pt_event__bindgen_ty_1__bindgen_ty_19() {
    assert_eq!(
        ::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_19>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_19)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_19>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_19)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1__bindgen_ty_19>())).payload as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1__bindgen_ty_19),
            "::",
            stringify!(payload)
        )
    );
}
#[test]
fn bindgen_test_layout_pt_event__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pt_event__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(pt_event__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_event__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_event__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_event__bindgen_ty_1>())).enabled as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_event__bindgen_ty_1>())).disabled as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1),
            "::",
            stringify!(disabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1>())).async_disabled as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1),
            "::",
            stringify!(async_disabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1>())).async_branch as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1),
            "::",
            stringify!(async_branch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_event__bindgen_ty_1>())).paging as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1),
            "::",
            stringify!(paging)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1>())).async_paging as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1),
            "::",
            stringify!(async_paging)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_event__bindgen_ty_1>())).overflow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1),
            "::",
            stringify!(overflow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1>())).exec_mode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1),
            "::",
            stringify!(exec_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_event__bindgen_ty_1>())).tsx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1),
            "::",
            stringify!(tsx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_event__bindgen_ty_1>())).vmcs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1),
            "::",
            stringify!(vmcs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pt_event__bindgen_ty_1>())).async_vmcs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1),
            "::",
            stringify!(async_vmcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_event__bindgen_ty_1>())).exstop as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1),
            "::",
            stringify!(exstop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_event__bindgen_ty_1>())).mwait as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1),
            "::",
            stringify!(mwait)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_event__bindgen_ty_1>())).pwre as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1),
            "::",
            stringify!(pwre)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_event__bindgen_ty_1>())).pwrx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1),
            "::",
            stringify!(pwrx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_event__bindgen_ty_1>())).ptwrite as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1),
            "::",
            stringify!(ptwrite)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_event__bindgen_ty_1>())).tick as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1),
            "::",
            stringify!(tick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_event__bindgen_ty_1>())).cbr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1),
            "::",
            stringify!(cbr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_event__bindgen_ty_1>())).mnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event__bindgen_ty_1),
            "::",
            stringify!(mnt)
        )
    );
}
#[test]
fn bindgen_test_layout_pt_event() {
    assert_eq!(
        ::std::mem::size_of::<pt_event>(),
        64usize,
        concat!("Size of: ", stringify!(pt_event))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_event>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_event>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_event>())).tsc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event),
            "::",
            stringify!(tsc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_event>())).lost_mtc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event),
            "::",
            stringify!(lost_mtc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_event>())).lost_cyc as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event),
            "::",
            stringify!(lost_cyc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_event>())).reserved as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_event>())).variant as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_event),
            "::",
            stringify!(variant)
        )
    );
}
impl pt_event {
    #[inline]
    pub fn ip_suppressed(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ip_suppressed(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn status_update(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_status_update(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_tsc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_tsc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ip_suppressed: u32,
        status_update: u32,
        has_tsc: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ip_suppressed: u32 = unsafe { ::std::mem::transmute(ip_suppressed) };
            ip_suppressed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let status_update: u32 = unsafe { ::std::mem::transmute(status_update) };
            status_update as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let has_tsc: u32 = unsafe { ::std::mem::transmute(has_tsc) };
            has_tsc as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " Allocate an Intel PT query decoder."]
    #[doc = ""]
    #[doc = " The decoder will work on the buffer defined in \\@config, it shall contain"]
    #[doc = " raw trace data and remain valid for the lifetime of the decoder."]
    #[doc = ""]
    #[doc = " The decoder needs to be synchronized before it can be used."]
    pub fn pt_qry_alloc_decoder(config: *const pt_config) -> *mut pt_query_decoder;
}
extern "C" {
    #[doc = " Free an Intel PT query decoder."]
    #[doc = ""]
    #[doc = " The \\@decoder must not be used after a successful return."]
    pub fn pt_qry_free_decoder(decoder: *mut pt_query_decoder);
}
extern "C" {
    #[doc = " Synchronize an Intel PT query decoder."]
    #[doc = ""]
    #[doc = " Search for the next synchronization point in forward or backward direction."]
    #[doc = ""]
    #[doc = " If \\@decoder has not been synchronized, yet, the search is started at the"]
    #[doc = " beginning of the trace buffer in case of forward synchronization and at the"]
    #[doc = " end of the trace buffer in case of backward synchronization."]
    #[doc = ""]
    #[doc = " If \\@ip is not NULL, set it to last ip."]
    #[doc = ""]
    #[doc = " Returns a non-negative pt_status_flag bit-vector on success, a negative error"]
    #[doc = " code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_bad_opc if an unknown packet is encountered."]
    #[doc = " Returns -pte_bad_packet if an unknown packet payload is encountered."]
    #[doc = " Returns -pte_eos if no further synchronization point is found."]
    #[doc = " Returns -pte_invalid if \\@decoder is NULL."]
    pub fn pt_qry_sync_forward(
        decoder: *mut pt_query_decoder,
        ip: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pt_qry_sync_backward(
        decoder: *mut pt_query_decoder,
        ip: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Manually synchronize an Intel PT query decoder."]
    #[doc = ""]
    #[doc = " Synchronize \\@decoder on the syncpoint at \\@offset.  There must be a PSB"]
    #[doc = " packet at \\@offset."]
    #[doc = ""]
    #[doc = " If \\@ip is not NULL, set it to last ip."]
    #[doc = ""]
    #[doc = " Returns a non-negative pt_status_flag bit-vector on success, a negative error"]
    #[doc = " code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_bad_opc if an unknown packet is encountered."]
    #[doc = " Returns -pte_bad_packet if an unknown packet payload is encountered."]
    #[doc = " Returns -pte_eos if \\@offset lies outside of \\@decoder's trace buffer."]
    #[doc = " Returns -pte_eos if \\@decoder reaches the end of its trace buffer."]
    #[doc = " Returns -pte_invalid if \\@decoder is NULL."]
    #[doc = " Returns -pte_nosync if there is no syncpoint at \\@offset."]
    pub fn pt_qry_sync_set(
        decoder: *mut pt_query_decoder,
        ip: *mut u64,
        offset: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current decoder position."]
    #[doc = ""]
    #[doc = " Fills the current \\@decoder position into \\@offset."]
    #[doc = ""]
    #[doc = " This is useful for reporting errors."]
    #[doc = ""]
    #[doc = " Returns zero on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_invalid if \\@decoder or \\@offset is NULL."]
    #[doc = " Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_qry_get_offset(
        decoder: *const pt_query_decoder,
        offset: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the position of the last synchronization point."]
    #[doc = ""]
    #[doc = " Fills the last synchronization position into \\@offset."]
    #[doc = ""]
    #[doc = " This is useful for splitting a trace stream for parallel decoding."]
    #[doc = ""]
    #[doc = " Returns zero on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_invalid if \\@decoder or \\@offset is NULL."]
    #[doc = " Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_qry_get_sync_offset(
        decoder: *const pt_query_decoder,
        offset: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pt_qry_get_config(decoder: *const pt_query_decoder) -> *const pt_config;
}
extern "C" {
    #[doc = " Query whether the next unconditional branch has been taken."]
    #[doc = ""]
    #[doc = " On success, provides 1 (taken) or 0 (not taken) in \\@taken for the next"]
    #[doc = " conditional branch and updates \\@decoder."]
    #[doc = ""]
    #[doc = " Returns a non-negative pt_status_flag bit-vector on success, a negative error"]
    #[doc = " code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_bad_opc if an unknown packet is encountered."]
    #[doc = " Returns -pte_bad_packet if an unknown packet payload is encountered."]
    #[doc = " Returns -pte_bad_query if no conditional branch is found."]
    #[doc = " Returns -pte_eos if decoding reached the end of the Intel PT buffer."]
    #[doc = " Returns -pte_invalid if \\@decoder or \\@taken is NULL."]
    #[doc = " Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_qry_cond_branch(
        decoder: *mut pt_query_decoder,
        taken: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the next indirect branch destination."]
    #[doc = ""]
    #[doc = " On success, provides the linear destination address of the next indirect"]
    #[doc = " branch in \\@ip and updates \\@decoder."]
    #[doc = ""]
    #[doc = " Returns a non-negative pt_status_flag bit-vector on success, a negative error"]
    #[doc = " code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_bad_opc if an unknown packet is encountered."]
    #[doc = " Returns -pte_bad_packet if an unknown packet payload is encountered."]
    #[doc = " Returns -pte_bad_query if no indirect branch is found."]
    #[doc = " Returns -pte_eos if decoding reached the end of the Intel PT buffer."]
    #[doc = " Returns -pte_invalid if \\@decoder or \\@ip is NULL."]
    #[doc = " Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_qry_indirect_branch(
        decoder: *mut pt_query_decoder,
        ip: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Query the next pending event."]
    #[doc = ""]
    #[doc = " On success, provides the next event \\@event and updates \\@decoder."]
    #[doc = ""]
    #[doc = " The \\@size argument must be set to sizeof(struct pt_event)."]
    #[doc = ""]
    #[doc = " Returns a non-negative pt_status_flag bit-vector on success, a negative error"]
    #[doc = " code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_bad_opc if an unknown packet is encountered."]
    #[doc = " Returns -pte_bad_packet if an unknown packet payload is encountered."]
    #[doc = " Returns -pte_bad_query if no event is found."]
    #[doc = " Returns -pte_eos if decoding reached the end of the Intel PT buffer."]
    #[doc = " Returns -pte_invalid if \\@decoder or \\@event is NULL."]
    #[doc = " Returns -pte_invalid if \\@size is too small."]
    #[doc = " Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_qry_event(
        decoder: *mut pt_query_decoder,
        event: *mut pt_event,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Query the current time."]
    #[doc = ""]
    #[doc = " On success, provides the time at the last query in \\@time."]
    #[doc = ""]
    #[doc = " The time is similar to what a rdtsc instruction would return.  Depending"]
    #[doc = " on the configuration, the time may not be fully accurate.  If TSC is not"]
    #[doc = " enabled, the time is relative to the last synchronization and can't be used"]
    #[doc = " to correlate with other TSC-based time sources.  In this case, -pte_no_time"]
    #[doc = " is returned and the relative time is provided in \\@time."]
    #[doc = ""]
    #[doc = " Some timing-related packets may need to be dropped (mostly due to missing"]
    #[doc = " calibration or incomplete configuration).  To get an idea about the quality"]
    #[doc = " of the estimated time, we record the number of dropped MTC and CYC packets."]
    #[doc = ""]
    #[doc = " If \\@lost_mtc is not NULL, set it to the number of lost MTC packets."]
    #[doc = " If \\@lost_cyc is not NULL, set it to the number of lost CYC packets."]
    #[doc = ""]
    #[doc = " Returns zero on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_invalid if \\@decoder or \\@time is NULL."]
    #[doc = " Returns -pte_no_time if there has not been a TSC packet."]
    pub fn pt_qry_time(
        decoder: *mut pt_query_decoder,
        time: *mut u64,
        lost_mtc: *mut u32,
        lost_cyc: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the current core bus ratio."]
    #[doc = ""]
    #[doc = " On success, provides the current core:bus ratio in \\@cbr.  The ratio is"]
    #[doc = " defined as core cycles per bus clock cycle."]
    #[doc = ""]
    #[doc = " Returns zero on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_invalid if \\@decoder or \\@cbr is NULL."]
    #[doc = " Returns -pte_no_cbr if there has not been a CBR packet."]
    pub fn pt_qry_core_bus_ratio(
        decoder: *mut pt_query_decoder,
        cbr: *mut u32,
    ) -> ::std::os::raw::c_int;
}
#[doc = " An Intel PT address space identifier."]
#[doc = ""]
#[doc = " This identifies a particular address space when adding file sections or"]
#[doc = " when reading memory."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_asid {
    #[doc = " The size of this object - set to sizeof(struct pt_asid)."]
    pub size: usize,
    #[doc = " The CR3 value."]
    pub cr3: u64,
    #[doc = " The VMCS Base address."]
    pub vmcs: u64,
}
#[test]
fn bindgen_test_layout_pt_asid() {
    assert_eq!(
        ::std::mem::size_of::<pt_asid>(),
        24usize,
        concat!("Size of: ", stringify!(pt_asid))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_asid>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_asid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_asid>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_asid),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_asid>())).cr3 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_asid),
            "::",
            stringify!(cr3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_asid>())).vmcs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_asid),
            "::",
            stringify!(vmcs)
        )
    );
}
pub const pt_asid_no_cr3: u64 = 18446744073709551615;
pub const pt_asid_no_vmcs: u64 = 18446744073709551615;
#[doc = " A cache of traced image sections."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_image_section_cache {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate a traced memory image section cache."]
    #[doc = ""]
    #[doc = " An optional \\@name may be given to the cache.  The name string is copied."]
    #[doc = ""]
    #[doc = " Returns a new traced memory image section cache on success, NULL otherwise."]
    pub fn pt_iscache_alloc(name: *const ::std::os::raw::c_char) -> *mut pt_image_section_cache;
}
extern "C" {
    #[doc = " Free a traced memory image section cache."]
    #[doc = ""]
    #[doc = " The \\@iscache must have been allocated with pt_iscache_alloc()."]
    #[doc = " The \\@iscache must not be used after a successful return."]
    pub fn pt_iscache_free(iscache: *mut pt_image_section_cache);
}
extern "C" {
    #[doc = " Set the image section cache limit."]
    #[doc = ""]
    #[doc = " Set the limit for a section cache in bytes.  A non-zero limit will keep the"]
    #[doc = " least recently used sections mapped until the limit is reached.  A limit of"]
    #[doc = " zero disables caching."]
    #[doc = ""]
    #[doc = " Returns zero on success, a negative pt_error_code otherwise."]
    #[doc = " Returns -pte_invalid if \\@iscache is NULL."]
    pub fn pt_iscache_set_limit(
        iscache: *mut pt_image_section_cache,
        limit: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the image section cache name."]
    #[doc = ""]
    #[doc = " Returns a pointer to \\@iscache's name or NULL if there is no name."]
    pub fn pt_iscache_name(iscache: *const pt_image_section_cache)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Add a new file section to the traced memory image section cache."]
    #[doc = ""]
    #[doc = " Adds a new section consisting of \\@size bytes starting at \\@offset in"]
    #[doc = " \\@filename loaded at the virtual address \\@vaddr if \\@iscache does not"]
    #[doc = " already contain such a section."]
    #[doc = ""]
    #[doc = " Returns an image section identifier (isid) uniquely identifying that section"]
    #[doc = " in \\@iscache."]
    #[doc = ""]
    #[doc = " The section is silently truncated to match the size of \\@filename."]
    #[doc = ""]
    #[doc = " Returns a positive isid on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_invalid if \\@iscache or \\@filename is NULL."]
    #[doc = " Returns -pte_invalid if \\@offset is too big."]
    pub fn pt_iscache_add_file(
        iscache: *mut pt_image_section_cache,
        filename: *const ::std::os::raw::c_char,
        offset: u64,
        size: u64,
        vaddr: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read memory from a cached file section"]
    #[doc = ""]
    #[doc = " Reads \\@size bytes of memory starting at virtual address \\@vaddr in the"]
    #[doc = " section identified by \\@isid in \\@iscache into \\@buffer."]
    #[doc = ""]
    #[doc = " The caller is responsible for allocating a \\@buffer of at least \\@size bytes."]
    #[doc = ""]
    #[doc = " The read request may be truncated if it crosses section boundaries or if"]
    #[doc = " \\@size is getting too big.  We support reading at least 4Kbyte in one chunk"]
    #[doc = " unless the read would cross a section boundary."]
    #[doc = ""]
    #[doc = " Returns the number of bytes read on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_invalid if \\@iscache or \\@buffer is NULL."]
    #[doc = " Returns -pte_invalid if \\@size is zero."]
    #[doc = " Returns -pte_nomap if \\@vaddr is not contained in section \\@isid."]
    #[doc = " Returns -pte_bad_image if \\@iscache does not contain \\@isid."]
    pub fn pt_iscache_read(
        iscache: *mut pt_image_section_cache,
        buffer: *mut u8,
        size: u64,
        isid: ::std::os::raw::c_int,
        vaddr: u64,
    ) -> ::std::os::raw::c_int;
}
#[doc = " The traced memory image."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_image {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate a traced memory image."]
    #[doc = ""]
    #[doc = " An optional \\@name may be given to the image.  The name string is copied."]
    #[doc = ""]
    #[doc = " Returns a new traced memory image on success, NULL otherwise."]
    pub fn pt_image_alloc(name: *const ::std::os::raw::c_char) -> *mut pt_image;
}
extern "C" {
    #[doc = " Free a traced memory image."]
    #[doc = ""]
    #[doc = " The \\@image must have been allocated with pt_image_alloc()."]
    #[doc = " The \\@image must not be used after a successful return."]
    pub fn pt_image_free(image: *mut pt_image);
}
extern "C" {
    #[doc = " Get the image name."]
    #[doc = ""]
    #[doc = " Returns a pointer to \\@image's name or NULL if there is no name."]
    pub fn pt_image_name(image: *const pt_image) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Add a new file section to the traced memory image."]
    #[doc = ""]
    #[doc = " Adds \\@size bytes starting at \\@offset in \\@filename. The section is"]
    #[doc = " loaded at the virtual address \\@vaddr in the address space \\@asid."]
    #[doc = ""]
    #[doc = " The \\@asid may be NULL or (partially) invalid.  In that case only the valid"]
    #[doc = " fields are considered when comparing with other address-spaces.  Use this"]
    #[doc = " when tracing a single process or when adding sections to all processes."]
    #[doc = ""]
    #[doc = " The section is silently truncated to match the size of \\@filename."]
    #[doc = ""]
    #[doc = " Existing sections that would overlap with the new section will be shrunk"]
    #[doc = " or split."]
    #[doc = ""]
    #[doc = " Returns zero on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_invalid if \\@image or \\@filename is NULL."]
    #[doc = " Returns -pte_invalid if \\@offset is too big."]
    pub fn pt_image_add_file(
        image: *mut pt_image,
        filename: *const ::std::os::raw::c_char,
        offset: u64,
        size: u64,
        asid: *const pt_asid,
        vaddr: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a section from an image section cache."]
    #[doc = ""]
    #[doc = " Add the section from \\@iscache identified by \\@isid in address space \\@asid."]
    #[doc = ""]
    #[doc = " Existing sections that would overlap with the new section will be shrunk"]
    #[doc = " or split."]
    #[doc = ""]
    #[doc = " Returns zero on success, a negative error code otherwise."]
    #[doc = " Returns -pte_invalid if \\@image or \\@iscache is NULL."]
    #[doc = " Returns -pte_bad_image if \\@iscache does not contain \\@isid."]
    pub fn pt_image_add_cached(
        image: *mut pt_image,
        iscache: *mut pt_image_section_cache,
        isid: ::std::os::raw::c_int,
        asid: *const pt_asid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy an image."]
    #[doc = ""]
    #[doc = " Adds all sections from \\@src to \\@image.  Sections that could not be added"]
    #[doc = " will be ignored."]
    #[doc = ""]
    #[doc = " Returns the number of ignored sections on success, a negative error code"]
    #[doc = " otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_invalid if \\@image or \\@src is NULL."]
    pub fn pt_image_copy(image: *mut pt_image, src: *const pt_image) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove all sections loaded from a file."]
    #[doc = ""]
    #[doc = " Removes all sections loaded from \\@filename from the address space \\@asid."]
    #[doc = " Specify the same \\@asid that was used for adding sections from \\@filename."]
    #[doc = ""]
    #[doc = " Returns the number of removed sections on success, a negative error code"]
    #[doc = " otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_invalid if \\@image or \\@filename is NULL."]
    pub fn pt_image_remove_by_filename(
        image: *mut pt_image,
        filename: *const ::std::os::raw::c_char,
        asid: *const pt_asid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove all sections loaded into an address space."]
    #[doc = ""]
    #[doc = " Removes all sections loaded into \\@asid.  Specify the same \\@asid that was"]
    #[doc = " used for adding sections."]
    #[doc = ""]
    #[doc = " Returns the number of removed sections on success, a negative error code"]
    #[doc = " otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_invalid if \\@image is NULL."]
    pub fn pt_image_remove_by_asid(
        image: *mut pt_image,
        asid: *const pt_asid,
    ) -> ::std::os::raw::c_int;
}
#[doc = " A read memory callback function."]
#[doc = ""]
#[doc = " It shall read \\@size bytes of memory from address space \\@asid starting"]
#[doc = " at \\@ip into \\@buffer."]
#[doc = ""]
#[doc = " It shall return the number of bytes read on success."]
#[doc = " It shall return a negative pt_error_code otherwise."]
pub type read_memory_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        buffer: *mut u8,
        size: usize,
        asid: *const pt_asid,
        ip: u64,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Set the memory callback for the traced memory image."]
    #[doc = ""]
    #[doc = " Sets \\@callback for reading memory.  The callback is used for addresses"]
    #[doc = " that are not found in file sections.  The \\@context argument is passed"]
    #[doc = " to \\@callback on each use."]
    #[doc = ""]
    #[doc = " There can only be one callback at any time.  A subsequent call will replace"]
    #[doc = " the previous callback.  If \\@callback is NULL, the callback is removed."]
    #[doc = ""]
    #[doc = " Returns -pte_invalid if \\@image is NULL."]
    pub fn pt_image_set_callback(
        image: *mut pt_image,
        callback: read_memory_callback_t,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub const pt_insn_class_ptic_error: pt_insn_class = 0;
pub const pt_insn_class_ptic_other: pt_insn_class = 1;
pub const pt_insn_class_ptic_call: pt_insn_class = 2;
pub const pt_insn_class_ptic_return: pt_insn_class = 3;
pub const pt_insn_class_ptic_jump: pt_insn_class = 4;
pub const pt_insn_class_ptic_cond_jump: pt_insn_class = 5;
pub const pt_insn_class_ptic_far_call: pt_insn_class = 6;
pub const pt_insn_class_ptic_far_return: pt_insn_class = 7;
pub const pt_insn_class_ptic_far_jump: pt_insn_class = 8;
pub const pt_insn_class_ptic_ptwrite: pt_insn_class = 9;
#[doc = " The instruction class."]
#[doc = ""]
#[doc = " We provide only a very coarse classification suitable for reconstructing"]
#[doc = " the execution flow."]
pub type pt_insn_class = i32;
pub const pt_max_insn_size: _bindgen_ty_1 = 15;
#[doc = " The maximal size of an instruction."]
pub type _bindgen_ty_1 = i32;
#[doc = " A single traced instruction."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_insn {
    #[doc = " The virtual address in its process."]
    pub ip: u64,
    #[doc = " The image section identifier for the section containing this"]
    #[doc = " instruction."]
    #[doc = ""]
    #[doc = " A value of zero means that the section did not have an identifier."]
    #[doc = " The section was not added via an image section cache or the memory"]
    #[doc = " was read via the read memory callback."]
    pub isid: ::std::os::raw::c_int,
    #[doc = " The execution mode."]
    pub mode: pt_exec_mode,
    #[doc = " A coarse classification."]
    pub iclass: pt_insn_class,
    #[doc = " The raw bytes."]
    pub raw: [u8; 15usize],
    #[doc = " The size in bytes."]
    pub size: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_pt_insn() {
    assert_eq!(
        ::std::mem::size_of::<pt_insn>(),
        40usize,
        concat!("Size of: ", stringify!(pt_insn))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_insn>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_insn))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_insn>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_insn),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_insn>())).isid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_insn),
            "::",
            stringify!(isid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_insn>())).mode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_insn),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_insn>())).iclass as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_insn),
            "::",
            stringify!(iclass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_insn>())).raw as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_insn),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_insn>())).size as *const _ as usize },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_insn),
            "::",
            stringify!(size)
        )
    );
}
impl pt_insn {
    #[inline]
    pub fn speculative(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_speculative(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn truncated(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_truncated(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        speculative: u32,
        truncated: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let speculative: u32 = unsafe { ::std::mem::transmute(speculative) };
            speculative as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let truncated: u32 = unsafe { ::std::mem::transmute(truncated) };
            truncated as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " Allocate an Intel PT instruction flow decoder."]
    #[doc = ""]
    #[doc = " The decoder will work on the buffer defined in \\@config, it shall contain"]
    #[doc = " raw trace data and remain valid for the lifetime of the decoder."]
    #[doc = ""]
    #[doc = " The decoder needs to be synchronized before it can be used."]
    pub fn pt_insn_alloc_decoder(config: *const pt_config) -> *mut pt_insn_decoder;
}
extern "C" {
    #[doc = " Free an Intel PT instruction flow decoder."]
    #[doc = ""]
    #[doc = " This will destroy the decoder's default image."]
    #[doc = ""]
    #[doc = " The \\@decoder must not be used after a successful return."]
    pub fn pt_insn_free_decoder(decoder: *mut pt_insn_decoder);
}
extern "C" {
    #[doc = " Synchronize an Intel PT instruction flow decoder."]
    #[doc = ""]
    #[doc = " Search for the next synchronization point in forward or backward direction."]
    #[doc = ""]
    #[doc = " If \\@decoder has not been synchronized, yet, the search is started at the"]
    #[doc = " beginning of the trace buffer in case of forward synchronization and at the"]
    #[doc = " end of the trace buffer in case of backward synchronization."]
    #[doc = ""]
    #[doc = " Returns zero or a positive value on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_bad_opc if an unknown packet is encountered."]
    #[doc = " Returns -pte_bad_packet if an unknown packet payload is encountered."]
    #[doc = " Returns -pte_eos if no further synchronization point is found."]
    #[doc = " Returns -pte_invalid if \\@decoder is NULL."]
    pub fn pt_insn_sync_forward(decoder: *mut pt_insn_decoder) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pt_insn_sync_backward(decoder: *mut pt_insn_decoder) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Manually synchronize an Intel PT instruction flow decoder."]
    #[doc = ""]
    #[doc = " Synchronize \\@decoder on the syncpoint at \\@offset.  There must be a PSB"]
    #[doc = " packet at \\@offset."]
    #[doc = ""]
    #[doc = " Returns zero or a positive value on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_bad_opc if an unknown packet is encountered."]
    #[doc = " Returns -pte_bad_packet if an unknown packet payload is encountered."]
    #[doc = " Returns -pte_eos if \\@offset lies outside of \\@decoder's trace buffer."]
    #[doc = " Returns -pte_eos if \\@decoder reaches the end of its trace buffer."]
    #[doc = " Returns -pte_invalid if \\@decoder is NULL."]
    #[doc = " Returns -pte_nosync if there is no syncpoint at \\@offset."]
    pub fn pt_insn_sync_set(decoder: *mut pt_insn_decoder, offset: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current decoder position."]
    #[doc = ""]
    #[doc = " Fills the current \\@decoder position into \\@offset."]
    #[doc = ""]
    #[doc = " This is useful for reporting errors."]
    #[doc = ""]
    #[doc = " Returns zero on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_invalid if \\@decoder or \\@offset is NULL."]
    #[doc = " Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_insn_get_offset(
        decoder: *const pt_insn_decoder,
        offset: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the position of the last synchronization point."]
    #[doc = ""]
    #[doc = " Fills the last synchronization position into \\@offset."]
    #[doc = ""]
    #[doc = " Returns zero on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_invalid if \\@decoder or \\@offset is NULL."]
    #[doc = " Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_insn_get_sync_offset(
        decoder: *const pt_insn_decoder,
        offset: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the traced image."]
    #[doc = ""]
    #[doc = " The returned image may be modified as long as no decoder that uses this"]
    #[doc = " image is running."]
    #[doc = ""]
    #[doc = " Returns a pointer to the traced image the decoder uses for reading memory."]
    #[doc = " Returns NULL if \\@decoder is NULL."]
    pub fn pt_insn_get_image(decoder: *mut pt_insn_decoder) -> *mut pt_image;
}
extern "C" {
    #[doc = " Set the traced image."]
    #[doc = ""]
    #[doc = " Sets the image that \\@decoder uses for reading memory to \\@image.  If \\@image"]
    #[doc = " is NULL, sets the image to \\@decoder's default image."]
    #[doc = ""]
    #[doc = " Only one image can be active at any time."]
    #[doc = ""]
    #[doc = " Returns zero on success, a negative error code otherwise."]
    #[doc = " Return -pte_invalid if \\@decoder is NULL."]
    pub fn pt_insn_set_image(
        decoder: *mut pt_insn_decoder,
        image: *mut pt_image,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pt_insn_get_config(decoder: *const pt_insn_decoder) -> *const pt_config;
}
extern "C" {
    #[doc = " Return the current time."]
    #[doc = ""]
    #[doc = " On success, provides the time at the last preceding timing packet in \\@time."]
    #[doc = ""]
    #[doc = " The time is similar to what a rdtsc instruction would return.  Depending"]
    #[doc = " on the configuration, the time may not be fully accurate.  If TSC is not"]
    #[doc = " enabled, the time is relative to the last synchronization and can't be used"]
    #[doc = " to correlate with other TSC-based time sources.  In this case, -pte_no_time"]
    #[doc = " is returned and the relative time is provided in \\@time."]
    #[doc = ""]
    #[doc = " Some timing-related packets may need to be dropped (mostly due to missing"]
    #[doc = " calibration or incomplete configuration).  To get an idea about the quality"]
    #[doc = " of the estimated time, we record the number of dropped MTC and CYC packets."]
    #[doc = ""]
    #[doc = " If \\@lost_mtc is not NULL, set it to the number of lost MTC packets."]
    #[doc = " If \\@lost_cyc is not NULL, set it to the number of lost CYC packets."]
    #[doc = ""]
    #[doc = " Returns zero on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_invalid if \\@decoder or \\@time is NULL."]
    #[doc = " Returns -pte_no_time if there has not been a TSC packet."]
    pub fn pt_insn_time(
        decoder: *mut pt_insn_decoder,
        time: *mut u64,
        lost_mtc: *mut u32,
        lost_cyc: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the current core bus ratio."]
    #[doc = ""]
    #[doc = " On success, provides the current core:bus ratio in \\@cbr.  The ratio is"]
    #[doc = " defined as core cycles per bus clock cycle."]
    #[doc = ""]
    #[doc = " Returns zero on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_invalid if \\@decoder or \\@cbr is NULL."]
    #[doc = " Returns -pte_no_cbr if there has not been a CBR packet."]
    pub fn pt_insn_core_bus_ratio(
        decoder: *mut pt_insn_decoder,
        cbr: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the current address space identifier."]
    #[doc = ""]
    #[doc = " On success, provides the current address space identifier in \\@asid."]
    #[doc = ""]
    #[doc = " The \\@size argument must be set to sizeof(struct pt_asid).  At most \\@size"]
    #[doc = " bytes will be copied and \\@asid->size will be set to the actual size of the"]
    #[doc = " provided address space identifier."]
    #[doc = ""]
    #[doc = " Returns zero on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_invalid if \\@decoder or \\@asid is NULL."]
    pub fn pt_insn_asid(
        decoder: *const pt_insn_decoder,
        asid: *mut pt_asid,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determine the next instruction."]
    #[doc = ""]
    #[doc = " On success, provides the next instruction in execution order in \\@insn."]
    #[doc = ""]
    #[doc = " The \\@size argument must be set to sizeof(struct pt_insn)."]
    #[doc = ""]
    #[doc = " Returns a non-negative pt_status_flag bit-vector on success, a negative error"]
    #[doc = " code otherwise."]
    #[doc = ""]
    #[doc = " Returns pts_eos to indicate the end of the trace stream.  Subsequent calls"]
    #[doc = " to pt_insn_next() will continue to return pts_eos until trace is required"]
    #[doc = " to determine the next instruction."]
    #[doc = ""]
    #[doc = " Returns -pte_bad_context if the decoder encountered an unexpected packet."]
    #[doc = " Returns -pte_bad_opc if the decoder encountered unknown packets."]
    #[doc = " Returns -pte_bad_packet if the decoder encountered unknown packet payloads."]
    #[doc = " Returns -pte_bad_query if the decoder got out of sync."]
    #[doc = " Returns -pte_eos if decoding reached the end of the Intel PT buffer."]
    #[doc = " Returns -pte_invalid if \\@decoder or \\@insn is NULL."]
    #[doc = " Returns -pte_nomap if the memory at the instruction address can't be read."]
    #[doc = " Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_insn_next(
        decoder: *mut pt_insn_decoder,
        insn: *mut pt_insn,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the next pending event."]
    #[doc = ""]
    #[doc = " On success, provides the next event in \\@event and updates \\@decoder."]
    #[doc = ""]
    #[doc = " The \\@size argument must be set to sizeof(struct pt_event)."]
    #[doc = ""]
    #[doc = " Returns a non-negative pt_status_flag bit-vector on success, a negative error"]
    #[doc = " code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_bad_query if there is no event."]
    #[doc = " Returns -pte_invalid if \\@decoder or \\@event is NULL."]
    #[doc = " Returns -pte_invalid if \\@size is too small."]
    pub fn pt_insn_event(
        decoder: *mut pt_insn_decoder,
        event: *mut pt_event,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " A block of instructions."]
#[doc = ""]
#[doc = " Instructions in this block are executed sequentially but are not necessarily"]
#[doc = " contiguous in memory.  Users are expected to follow direct branches."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_block {
    #[doc = " The IP of the first instruction in this block."]
    pub ip: u64,
    #[doc = " The IP of the last instruction in this block."]
    #[doc = ""]
    #[doc = " This can be used for error-detection."]
    pub end_ip: u64,
    #[doc = " The image section that contains the instructions in this block."]
    #[doc = ""]
    #[doc = " A value of zero means that the section did not have an identifier."]
    #[doc = " The section was not added via an image section cache or the memory"]
    #[doc = " was read via the read memory callback."]
    pub isid: ::std::os::raw::c_int,
    #[doc = " The execution mode for all instructions in this block."]
    pub mode: pt_exec_mode,
    #[doc = " The instruction class for the last instruction in this block."]
    #[doc = ""]
    #[doc = " This field may be set to ptic_error to indicate that the instruction"]
    #[doc = " class is not available.  The block decoder may choose to not provide"]
    #[doc = " the instruction class in some cases for performance reasons."]
    pub iclass: pt_insn_class,
    #[doc = " The number of instructions in this block."]
    pub ninsn: u16,
    #[doc = " The raw bytes of the last instruction in this block in case the"]
    #[doc = " instruction does not fit entirely into this block's section."]
    #[doc = ""]
    #[doc = " This field is only valid if \\@truncated is set."]
    pub raw: [u8; 15usize],
    #[doc = " The size of the last instruction in this block in bytes."]
    #[doc = ""]
    #[doc = " This field is only valid if \\@truncated is set."]
    pub size: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 9usize],
}
#[test]
fn bindgen_test_layout_pt_block() {
    assert_eq!(
        ::std::mem::size_of::<pt_block>(),
        56usize,
        concat!("Size of: ", stringify!(pt_block))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_block>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_block))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_block>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_block),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_block>())).end_ip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_block),
            "::",
            stringify!(end_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_block>())).isid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_block),
            "::",
            stringify!(isid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_block>())).mode as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_block),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_block>())).iclass as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_block),
            "::",
            stringify!(iclass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_block>())).ninsn as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_block),
            "::",
            stringify!(ninsn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_block>())).raw as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_block),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_block>())).size as *const _ as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_block),
            "::",
            stringify!(size)
        )
    );
}
impl pt_block {
    #[inline]
    pub fn speculative(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_speculative(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn truncated(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_truncated(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        speculative: u32,
        truncated: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let speculative: u32 = unsafe { ::std::mem::transmute(speculative) };
            speculative as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let truncated: u32 = unsafe { ::std::mem::transmute(truncated) };
            truncated as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " Allocate an Intel PT block decoder."]
    #[doc = ""]
    #[doc = " The decoder will work on the buffer defined in \\@config, it shall contain"]
    #[doc = " raw trace data and remain valid for the lifetime of the decoder."]
    #[doc = ""]
    #[doc = " The decoder needs to be synchronized before it can be used."]
    pub fn pt_blk_alloc_decoder(config: *const pt_config) -> *mut pt_block_decoder;
}
extern "C" {
    #[doc = " Free an Intel PT block decoder."]
    #[doc = ""]
    #[doc = " This will destroy the decoder's default image."]
    #[doc = ""]
    #[doc = " The \\@decoder must not be used after a successful return."]
    pub fn pt_blk_free_decoder(decoder: *mut pt_block_decoder);
}
extern "C" {
    #[doc = " Synchronize an Intel PT block decoder."]
    #[doc = ""]
    #[doc = " Search for the next synchronization point in forward or backward direction."]
    #[doc = ""]
    #[doc = " If \\@decoder has not been synchronized, yet, the search is started at the"]
    #[doc = " beginning of the trace buffer in case of forward synchronization and at the"]
    #[doc = " end of the trace buffer in case of backward synchronization."]
    #[doc = ""]
    #[doc = " Returns zero or a positive value on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_bad_opc if an unknown packet is encountered."]
    #[doc = " Returns -pte_bad_packet if an unknown packet payload is encountered."]
    #[doc = " Returns -pte_eos if no further synchronization point is found."]
    #[doc = " Returns -pte_invalid if \\@decoder is NULL."]
    pub fn pt_blk_sync_forward(decoder: *mut pt_block_decoder) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pt_blk_sync_backward(decoder: *mut pt_block_decoder) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Manually synchronize an Intel PT block decoder."]
    #[doc = ""]
    #[doc = " Synchronize \\@decoder on the syncpoint at \\@offset.  There must be a PSB"]
    #[doc = " packet at \\@offset."]
    #[doc = ""]
    #[doc = " Returns zero or a positive value on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_bad_opc if an unknown packet is encountered."]
    #[doc = " Returns -pte_bad_packet if an unknown packet payload is encountered."]
    #[doc = " Returns -pte_eos if \\@offset lies outside of \\@decoder's trace buffer."]
    #[doc = " Returns -pte_eos if \\@decoder reaches the end of its trace buffer."]
    #[doc = " Returns -pte_invalid if \\@decoder is NULL."]
    #[doc = " Returns -pte_nosync if there is no syncpoint at \\@offset."]
    pub fn pt_blk_sync_set(decoder: *mut pt_block_decoder, offset: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current decoder position."]
    #[doc = ""]
    #[doc = " Fills the current \\@decoder position into \\@offset."]
    #[doc = ""]
    #[doc = " This is useful for reporting errors."]
    #[doc = ""]
    #[doc = " Returns zero on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_invalid if \\@decoder or \\@offset is NULL."]
    #[doc = " Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_blk_get_offset(
        decoder: *const pt_block_decoder,
        offset: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the position of the last synchronization point."]
    #[doc = ""]
    #[doc = " Fills the last synchronization position into \\@offset."]
    #[doc = ""]
    #[doc = " Returns zero on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_invalid if \\@decoder or \\@offset is NULL."]
    #[doc = " Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_blk_get_sync_offset(
        decoder: *const pt_block_decoder,
        offset: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the traced image."]
    #[doc = ""]
    #[doc = " The returned image may be modified as long as \\@decoder is not running."]
    #[doc = ""]
    #[doc = " Returns a pointer to the traced image \\@decoder uses for reading memory."]
    #[doc = " Returns NULL if \\@decoder is NULL."]
    pub fn pt_blk_get_image(decoder: *mut pt_block_decoder) -> *mut pt_image;
}
extern "C" {
    #[doc = " Set the traced image."]
    #[doc = ""]
    #[doc = " Sets the image that \\@decoder uses for reading memory to \\@image.  If \\@image"]
    #[doc = " is NULL, sets the image to \\@decoder's default image."]
    #[doc = ""]
    #[doc = " Only one image can be active at any time."]
    #[doc = ""]
    #[doc = " Returns zero on success, a negative error code otherwise."]
    #[doc = " Return -pte_invalid if \\@decoder is NULL."]
    pub fn pt_blk_set_image(
        decoder: *mut pt_block_decoder,
        image: *mut pt_image,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pt_blk_get_config(decoder: *const pt_block_decoder) -> *const pt_config;
}
extern "C" {
    #[doc = " Return the current time."]
    #[doc = ""]
    #[doc = " On success, provides the time at the last preceding timing packet in \\@time."]
    #[doc = ""]
    #[doc = " The time is similar to what a rdtsc instruction would return.  Depending"]
    #[doc = " on the configuration, the time may not be fully accurate.  If TSC is not"]
    #[doc = " enabled, the time is relative to the last synchronization and can't be used"]
    #[doc = " to correlate with other TSC-based time sources.  In this case, -pte_no_time"]
    #[doc = " is returned and the relative time is provided in \\@time."]
    #[doc = ""]
    #[doc = " Some timing-related packets may need to be dropped (mostly due to missing"]
    #[doc = " calibration or incomplete configuration).  To get an idea about the quality"]
    #[doc = " of the estimated time, we record the number of dropped MTC and CYC packets."]
    #[doc = ""]
    #[doc = " If \\@lost_mtc is not NULL, set it to the number of lost MTC packets."]
    #[doc = " If \\@lost_cyc is not NULL, set it to the number of lost CYC packets."]
    #[doc = ""]
    #[doc = " Returns zero on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_invalid if \\@decoder or \\@time is NULL."]
    #[doc = " Returns -pte_no_time if there has not been a TSC packet."]
    pub fn pt_blk_time(
        decoder: *mut pt_block_decoder,
        time: *mut u64,
        lost_mtc: *mut u32,
        lost_cyc: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the current core bus ratio."]
    #[doc = ""]
    #[doc = " On success, provides the current core:bus ratio in \\@cbr.  The ratio is"]
    #[doc = " defined as core cycles per bus clock cycle."]
    #[doc = ""]
    #[doc = " Returns zero on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_invalid if \\@decoder or \\@cbr is NULL."]
    #[doc = " Returns -pte_no_cbr if there has not been a CBR packet."]
    pub fn pt_blk_core_bus_ratio(
        decoder: *mut pt_block_decoder,
        cbr: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the current address space identifier."]
    #[doc = ""]
    #[doc = " On success, provides the current address space identifier in \\@asid."]
    #[doc = ""]
    #[doc = " The \\@size argument must be set to sizeof(struct pt_asid).  At most \\@size"]
    #[doc = " bytes will be copied and \\@asid->size will be set to the actual size of the"]
    #[doc = " provided address space identifier."]
    #[doc = ""]
    #[doc = " Returns zero on success, a negative error code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_invalid if \\@decoder or \\@asid is NULL."]
    pub fn pt_blk_asid(
        decoder: *const pt_block_decoder,
        asid: *mut pt_asid,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determine the next block of instructions."]
    #[doc = ""]
    #[doc = " On success, provides the next block of instructions in execution order in"]
    #[doc = " \\@block."]
    #[doc = ""]
    #[doc = " The \\@size argument must be set to sizeof(struct pt_block)."]
    #[doc = ""]
    #[doc = " Returns a non-negative pt_status_flag bit-vector on success, a negative error"]
    #[doc = " code otherwise."]
    #[doc = ""]
    #[doc = " Returns pts_eos to indicate the end of the trace stream.  Subsequent calls"]
    #[doc = " to pt_block_next() will continue to return pts_eos until trace is required"]
    #[doc = " to determine the next instruction."]
    #[doc = ""]
    #[doc = " Returns -pte_bad_context if the decoder encountered an unexpected packet."]
    #[doc = " Returns -pte_bad_opc if the decoder encountered unknown packets."]
    #[doc = " Returns -pte_bad_packet if the decoder encountered unknown packet payloads."]
    #[doc = " Returns -pte_bad_query if the decoder got out of sync."]
    #[doc = " Returns -pte_eos if decoding reached the end of the Intel PT buffer."]
    #[doc = " Returns -pte_invalid if \\@decoder or \\@block is NULL."]
    #[doc = " Returns -pte_nomap if the memory at the instruction address can't be read."]
    #[doc = " Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_blk_next(
        decoder: *mut pt_block_decoder,
        block: *mut pt_block,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the next pending event."]
    #[doc = ""]
    #[doc = " On success, provides the next event in \\@event and updates \\@decoder."]
    #[doc = ""]
    #[doc = " The \\@size argument must be set to sizeof(struct pt_event)."]
    #[doc = ""]
    #[doc = " Returns a non-negative pt_status_flag bit-vector on success, a negative error"]
    #[doc = " code otherwise."]
    #[doc = ""]
    #[doc = " Returns -pte_bad_query if there is no event."]
    #[doc = " Returns -pte_invalid if \\@decoder or \\@event is NULL."]
    #[doc = " Returns -pte_invalid if \\@size is too small."]
    pub fn pt_blk_event(
        decoder: *mut pt_block_decoder,
        event: *mut pt_event,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
